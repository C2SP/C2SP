# COCKTAIL Distributed Key Generation

[c2sp.org/cocktail-dkg](https://c2sp.org/cocktail-dkg)

- **Version**: v0.1.0
- **Authors**:
  - [Daniel Bourdrez](https://github.com/bytemare)
  - [Soatok Dreamseeker](https://github.com/soatok)
  - [Tjaden Hess](https://github.com/tjade273), *[Trail of Bits](https://trailofbits.com)*
  - COCKTAIL is an independent derivative of [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg/tree/master),
    which was made by:
    - [Tim Ruffing](https://github.com/real-or-random), *Blockstream Research*
    - [Jonas Nick](https://github.com/jonasnick), *Blockstream Research*

## Introduction

Threshold signature schemes (i.e., [FROST (RFC 9591)](https://www.rfc-editor.org/rfc/rfc9591.html)) allow a secret key
be shared among $n$ parties such that any $t$ of the $n$ parties can cooperate to generate a digital signature for the
group public key.

Initializing a $t$-of-$n$ threshold requires a key generation protocol. This can be a **Distributed Key Generation**
(DKG) protocol or a Trusted Dealer approach. RFC 9591 specifies a Trusted Dealer approach and leaves DKG specification
out of scope.

However, [the original FROST paper](https://eprint.iacr.org/2020/852) did specify a DKG protocol based on Verifiable
Secret Sharing, Pedersen commitments, and Proofs of Possession. This protocol is secure only if communications are
performed over a secure channel, with the following requirements:

- Messages are authenticated and encrypted in transit, to prevent man-in-the-middle attacks
- All participants have some consensus mechanism (e.g., a transparency log) so everyone has a consistent view of the
  protocol messages

To satisfy these requirements in a standalone protocol, Nick and Ruffing proposed [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg)
as a Bitcoin Improvement Proposal. Because of its tight coupling to the Bitcoin project, ChillDKG was only specified and
implemented over the secp256k1 elliptic curve group.

> COCKTAIL is a recursive acronym that stands for: "COCKTAIL Orchestrates Cryptographic Key Threshold Agreement for
> Interoperable Libraries."

COCKTAIL is an independent derivative of ChillDKG intended to be used with any FROST ciphersuite.

## Abstract

COCKTAIL-DKG is a standalone, three-round distributed key generation protocol for threshold signature schemes like 
FROST.

COCKTAIL-DKG allows a group of $n$ participants to securely generate a shared group public key and individual secret
shares for a $t$-of-$n$ threshold, without a trusted dealer. The protocol is built on Feldman's Verifiable Secret
Sharing (VSS), uses pairwise ECDH to encrypt shares for transport over insecure channels, and includes a final
certification round to ensure all participants agree on the outcome. It is designed to be ciphersuite-agile, with
specific recommendations for curves like secp256k1, Ed25519 (via Ristretto255), and Ed448 (via Decaf448).

## Design Overview

COCKTAIL-DKG, like ChillDKG before it, starts off with a simplified variant of a Pedersen Commitment with Proof of
Possession protocol, referred to as "SimplPedPop". If SimplPedPop were a standalone protocol, it would depend on an
external *equality check protocol* to ensure all participants received the same messages.

An encryption layer, called "EncPedPop", wraps SimplPedPop with pairwise ECDH to encrypt secret shares.

Finally, an equality check protocol called "CertEq" is built atop EncPedPop to create a standalone protocol.

A **coordinator** is assumed to facilitate message passing between participants. The coordinator is a trusted third
party that is responsible for receiving messages from all participants, aggregating them where necessary, and
broadcasting them to all participants. The coordinator does not have access to any secret information. The role of the
coordinator can be fulfilled by a simple broadcast channel, a peer-to-peer network, or a dedicated server application.

## Supporting Definitions

This section provides detailed definitions for the notation, message formats, and cryptographic primitives used
throughout the COCKTAIL-DKG protocol.

### Notation

- $X \parallel Y$: The concatenation of X followed by Y.
- $n$: The total number of participants in the DKG ceremony.
- $t$: The threshold, i.e., the minimum number of participants required to generate a signature.
- $i, j$: Indices representing participants, where $1 <= i, j <= n$.
- $B$: The generator point of the elliptic curve group.
- $q$: The order of the elliptic curve group.
- $f_i(x)$: The secret polynomial of degree $t-1$ generated by participant $i$.
- $a_{i,k}$: The $k$-th coefficient of $f_i(x)$, which is a scalar. $a_{i,0}$ is the primary secret of participant $i$.
- $C_{i,k}$: The public commitment to the coefficient $a_{i,k}$, where $C_{i,k} = a_{i,k} * B$.
- $C_i$: The VSS commitment for participant $i$, which is the vector of all $C_{i,k}$.
- $s_{i,j}$: The secret share of participant $i$'s polynomial evaluated at $j$, i.e., $s_{i,j} = f_i(j)$.
- $d_i$: The long-term static private key for participant $i$, a scalar.
- $P_i$: The long-term static public key for participant $i$, where $P_i = d_i * B$.
- $e_i$: The ephemeral private key for participant $i$ for a single DKG session, a scalar.
- $E_i$: The ephemeral public key for participant $i$, where $E_i = e_i * B$.
- $PoP_i$: A Proof of Possession signature from participant $i$.
- $x_i$: The final, long-lived secret share for participant $i$, where $x_i = \sum_{j=1}^{n} s_{j,i}$.
- $Y_i$: The public verification share for participant $i$.
- $Y$: The final group public key, where $Y = \sum_{j=1}^{n} C_{j,0}$.
- $payload_{i,j}$: An optional application-defined payload from participant $i$ to participant $j$, which may be empty.
- $S^{(e)}_{i,j}$: The ephemeral-to-static ECDH shared secret, where $S^{(e)}_{i,j} = e_i * P_j$.
- $S^{(d)}_{i,j}$: The static-to-static ECDH shared secret, where $S^{(d)}_{i,j} = d_i * P_j$.

### Operations

- $Add(P1, P2)$: Elliptic curve point addition.
- $RandomScalar()$: Generates a uniform cryptographically secure random scalar in the range $[0, q-1]$.
- $H6()$: A ciphersuite-specific key derivation function.
- $Enc()$/$Dec()$: Ciphersuite-specific AEAD encryption/decryption functions.
- $Sign()$/$Verify()$: Ciphersuite-specific digital signature functions for the Proof of Possession.

### Message Formats

All messages exchanged between participants are encoded as byte arrays. The specific encoding of protocol elements is
defined below. Implementations **MUST** adhere to these formats to ensure interoperability.

#### Primitive Types

Let $G$ be an elliptic curve group with a standardized name (e.g., "P-256", "Ed25519", "secp256k1").

- **Scalar**: A scalar is an integer in the range $[0, q-1]$, where $q$ is the order of the group $G$. A scalar is
  encoded as a fixed-size, big-endian byte array. The size is determined by the curve (e.g., 32 bytes for P-256,
  secp256k1, and Ed25519/Ristretto255). Implementations **MUST** reject any decoded scalar value $s$ where $s \geq q$.
- **Elliptic Curve Point**: An elliptic curve point is encoded in its compressed form, as a fixed-size byte array. The
  size and format are determined by the curve (e.g., 33 bytes for P-256 and secp256k1, 32 bytes for
  Ed25519/Ristretto255). Implementations **MUST** validate that decoded points are valid curve points.
- **The Point at Infinity**: The point at infinity, which is the identity element of the group, is represented by a byte
  array of the same length as a standard point encoding, but filled with all zero bytes. The point at infinity **MUST**
  be rejected when parsing VSS commitment points $C_{i,k}$, ephemeral public keys $E_i$, and static public keys $P_i$.
  Accepting identity elements in these positions would compromise protocol security.

#### Protocol Messages

The following messages are exchanged during the COCKTAIL-DKG protocol. They are constructed by concatenating the byte
representations of their constituent parts in the specified order.

**1. $msg_{1|i}$ (Participant -> Coordinator, Round 1)**

This message contains the participant's VSS commitment, their Proof-of-Possession, their ephemeral public key, and the
encrypted shares for all other participants.

- $C_i$: The VSS commitment, which is a list of **exactly** $t$ elliptic curve points. Implementations **MUST** verify
  that the commitment contains exactly $t$ points; any other length indicates a malformed message or an attempted
  [threshold elevation attack](https://blog.trailofbits.com/2024/02/20/breaking-the-shared-key-in-threshold-signature-schemes/).
  - Format: $C_{i,0} \parallel C_{i,1} \parallel \cdots \parallel C_{i,t-1}$
- $PoP_i$: The Proof of Possession, which is a signature. The size depends on the signature scheme used by the
  ciphersuite.
- $E_i$: The ephemeral public key, an elliptic curve point.
  - It does not refer to isogenies. Here, E stands for "ephemeral".
- $c_{i,j}$: An encrypted ciphertext containing the secret share $s_{i,j}$ and an optional application-defined payload
  $payload_{i,j}$. The plaintext format is $s_{i,j} \parallel payload_{i,j}$, where $payload_{i,j}$ may be empty.
  The ciphertext size depends on the AEAD scheme and the payload size. The minimum ciphertext size is the scalar
  encoding size plus the AEAD authentication tag size (e.g., 32 + 16 = 48 bytes for most ciphersuites).
  Implementations **SHOULD** enforce a maximum ciphertext size to prevent resource exhaustion attacks.

The full message is the concatenation of these elements:

```math
msg_{1|i} = C_i \parallel PoP_i \parallel E_i \parallel c_{i,1} \parallel c_{i,2} \parallel \cdots \parallel c_{i,n}
```

**2. $msg2$ (Coordinator -> All Participants, Round 2)**

This message aggregates the public information from all participants.

- $C_{j,0}$: The zero-coefficient commitment from participant $j$, an elliptic curve point.
- $PoP_j$: The Proof of Possession from participant $j$.
- $C_{agg}$: The aggregated commitment for non-zero coefficients. This is a list of $t-1$ points.
  - Format: $C_{agg,1} \parallel \cdots \parallel C_{agg,t-1}$
- $E_j$: The ephemeral public key from participant $j$.
- $c_{j,i}$: The ciphertext from participant $j$ intended for participant $i$.

The message broadcast to participant $i$ is structured as:

```math
msg_{2|i} = (C_{1,0} \parallel PoP_1) \parallel \cdots \parallel (C_{n,0} \parallel PoP_n) \parallel C_{agg} \parallel E_1 \parallel \cdots \parallel E_n \parallel c_{1,i} \parallel \cdots \parallel c_{n,i}
```

**3. $sig_i$ (Participant -> Coordinator, CertEq Phase)**

This message contains the participant's signature over the protocol transcript.

- $sig_i$: The signature, created using the participant's static private key $d_i$. The size depends on the signature
  scheme.

**4. Aggregated Signatures (Coordinator -> All Participants, CertEq Phase)**

This is the final message, containing all signatures on the transcript.

- $sig_j$: The signature from participant $j$.

The message is structured as:

```math
aggregated_sigs = sig_1 \parallel sig_2 \parallel \cdots \parallel sig_n
```

### Cryptographic Primitives

As COCKTAIL-DKG is intended to be used in conjunction with [RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html), we
begin our enumeration of named hash functions with "H6".

## Protocol Definition

This section describes the COCKTAIL-DKG protocol in detail.

### Setup

Each participant $i$ is assumed to have:

- A unique identifier $i$ from $1$ to $n$. Identifiers **MUST NOT** be $0$ or congruent to $0$ modulo the group order
  $q$, as this would allow a [zero share attack](https://www.zkdocs.com/docs/zkdocs/protocol-primitives/verifiable-secret-sharing/).
- The parameters $n$ (total participants) and $t$ (threshold).
- A long-term static key pair $(d_i, P_i)$.
- A list of the static public keys of all other participants, ${P_1, ..., P_n}$.
- A ciphersuite defining the elliptic curve group, hash function, and AEAD scheme.
- A `context` string, which **MUST** be unique to the DKG session to prevent replay attacks. It is RECOMMENDED that this
  string be constructed by hashing a domain separation tag, the session ID, and the list of participant public keys,
  for example: `context = H("COCKTAIL-DKG-CONTEXT" || session_id || P_1 || P_2 || ... || P_n)`. The `session_id` should
  be a value that is unique to the session, such as a high-entropy random byte string or a timestamp. All participants
  **MUST** validate that they agree on the `context` string before proceeding.

### Round 1: Commitment and Encryption

1. **Generate Polynomial:** Participant $i$ generates a secret polynomial $f_i(x)$ of degree $t-1$:
   $f_i(x) = a_{i,0} + a_{i,1}x + \cdots + a_{i,t-1}x^{t-1}$.
   The coefficients $a_{i,k}$ are chosen as random scalars. $a_{i,0}$ is the participant's primary secret share.
2. **Compute VSS Commitment:** Participant $i$ computes a VSS commitment $C_i$ to their polynomial by creating a public
   commitment for each coefficient:
   $C_i = (C_{i,0}, C_{i,1}, \cdots, C_{i,t-1})$, where $C_{i,k} = a_{i,k} * B$.
3. **Generate Ephemeral Key:** Participant $i$ generates a fresh ephemeral key pair $(e_i, E_i)$ for this session.
4. **Compute Proof of Possession (PoP):** Participant $i$ computes a digital signature $PoP_i$ over a concatenation of
   the `context` string, their VSS commitment $C_i$, and their ephemeral public key $E_i$. The signature is created
   using the secret $a_{i,0}$ as the private key and $C_{i,0}$ as the public key. The message to be signed is
   `context || C_i || E_i`. The specific signature algorithm is defined by the ciphersuite.
5. **Compute and Encrypt Shares:** For each participant $j$ from $1$ to $n$ (including $j = i$, the self-share):
    1. **Compute Share:** Participant $i$ computes the secret share $s_{i,j} = f_i(j)$.
    2. **Derive Key:** Participant $i$ computes two ECDH shared secrets: one with their ephemeral key and the
       recipient's static public key, and one with their static key and the recipient's static public key:
       $S^{(e)}_{i,j} = e_i * P_j$ and $S^{(d)}_{i,j} = d_i * P_j$. It then derives a symmetric key and nonce for the AEAD.
        - If the hash function has an output length at least 480 bits long:
            - $tmp = H6(S^{(e)}_{i,j} \parallel S^{(d)}_{i,j}, E_i, P_i, P_j, context)$.
            - $k_{i,j} = tmp[0:32]$
            - $iv_{i,j} = tmp[32:56]$
        - Otherwise:
            - $ikm = H6(S^{(e)}_{i,j} \parallel S^{(d)}_{i,j}, E_i, P_i, P_j, context)$.
            - $k_{i,j} = H("COCKTAIL-derive-key" \parallel ikm)$
            - $iv_{i,j} = H("COCKTAIL-derive-nonce" \parallel ikm)[0:24]$
            - Here, $H(x)$ is the underlying hash function (e.g., SHA-256).
    3. **Prepare Plaintext:** Participant $i$ prepares the plaintext to encrypt. This consists of the secret share
       $s_{i,j}$ followed by an optional application-defined payload $payload_{i,j}$:
       $plaintext_{i,j} = s_{i,j} \parallel payload_{i,j}$.
       If no application payload is used, $payload_{i,j}$ is empty.
    4. **Encrypt Share:** Participant $i$ encrypts the plaintext for participant $j$:
       $c_{i,j} = Enc(plaintext_{i,j}, k_{i,j}, iv_{i,j})$.
6. **Broadcast:** Participant $i$ sends their $msg_{1|i}$ to the coordinator.

### Round 2: Share Decryption and Verification

The coordinator waits to receive $msg_{1|i}$ from all $n$ participants. It then broadcasts a list of all received messages
to every participant. Upon receiving the list of all $msg_{1|i}$ messages, each participant $i$ performs the following
steps:

1. **Validate Commitments:** For each participant $j$ from $1$ to $n$:
    - Participant $i$ verifies that the VSS commitment $C_j$ contains **exactly** $t$ points. If $|C_j| \neq t$,
      participant $i$ **MUST** abort, identifying participant $j$ as malicious. This check prevents
      [threshold elevation attacks](https://blog.trailofbits.com/2024/02/20/breaking-the-shared-key-in-threshold-signature-schemes/).
2. **Verify All PoPs:** For each participant $j$ from $1$ to $n$:
    - Participant $i$ verifies the proof of possession $PoP_j$. The signature is checked against the message
      `context || C_j || E_j`, using participant $j$'s public commitment $C_{j,0}$ as the public key.
    - If any $PoP_j$ is invalid, participant $i$ **MUST** abort, identifying participant $j$ as malicious.
3. **Decrypt and Verify Shares:** For each participant $j$ from $1$ to $n$ (including the self-share $j = i$):
    1. **Derive Key:** Participant $i$ computes two ECDH shared secrets: one with the sender's ephemeral public key
       and their static key, and one with the sender's static public key and their static key:
       $S^{(e)}_{j,i} = d_i * E_j$ and $S^{(d)}_{j,i} = d_i * P_j$. They then derive the symmetric key and nonce:
        - If the hash function has an output length at least 480 bits long:
            - $tmp = H6(S^{(e)}_{j,i} \parallel S^{(d)}_{j,i}, E_j, P_j, P_i, context)$.
            - $k_{j,i} = tmp[0:32]$
            - $iv_{j,i} = tmp[32:56]$
        - Otherwise:
            - $ikm = H6(S^{(e)}_{j,i} \parallel S^{(d)}_{j,i}, E_j, P_j, P_i, context)$.
            - $k_{j,i} = H("COCKTAIL-derive-key" \parallel ikm)$
            - $iv_{j,i} = H("COCKTAIL-derive-nonce" \parallel ikm)[0:24]$
            - Here, $H(x)$ is the underlying hash function (e.g., SHA-256).
    2. **Decrypt Plaintext:** Participant $i$ decrypts the ciphertext sent to them from participant $j$:
       $plaintext_{j,i} = Dec(c_{j,i}, k_{j,i}, iv_{j,i})$.
       If decryption fails, participant $i$ **MUST** abort, identifying $j$ as malicious.
    3. **Parse Plaintext:** Participant $i$ parses the plaintext to extract the secret share $s_{j,i}$ (the first
       scalar-sized portion) and any optional application payload $payload_{j,i}$ (the remainder).
    4. **Verify Share:** Participant $i$ verifies the decrypted share $s_{j,i}$ against $j$'s VSS commitment:
       $s_{j,i} * B = \sum_{k=0}^{t-1} i^k * C_{j,k}$
       If the check fails, participant $i$ **MUST** abort, identifying $j$ as malicious.
4.  **Compute Final Keys:** If all shares are successfully decrypted and verified:
    1. **Secret Share:** Participant $i$ computes their final long-lived secret share by summing all received shares:
       $x_i = \sum_{j=1}^{n} s_{j,i}$.
    2. **Group Public Key:** Participant $i$ computes the group public key:
       $Y = \sum_{j=1}^n C_{j,0}$.
    3. **Verification Share:** Participant $i$ computes their public verification share $Y_i$. This is done by first
       computing the aggregated commitment for each coefficient $k$:
       $C_{agg,k} = \sum_{j=1}^{n} C_{j,k}$.
       Then, $Y_i = \sum_{k=0}^{t-1} i^k * C_{agg,k}$.
    4. **Final Check:** Participant $i$ performs a final self-consistency check:
       $x_i * B = Y_i$. If this check fails, the participant must abort. Note: This check is mathematically
       guaranteed to pass if all VSS share verifications in step 3.4 succeeded. It serves as a defense-in-depth
       measure to catch implementation bugs in the share summation or verification share computation.

### Round 3: Certification

This round ensures that all honest participants have arrived at the same public state.

1. **Construct Transcript:** Each participant $i$ constructs a canonical byte representation of the final public
   transcript, $T$. The transcript **MUST** be constructed by concatenating the following elements in this exact order:
    1. $len(context)$: The length of the context string as a little-endian 64-bit unsigned integer.
    2. $context$: The context string bytes.
    3. $n$: The number of participants as a little-endian 32-bit unsigned integer.
    4. $t$: The threshold as a little-endian 32-bit unsigned integer.
    5. For $j$ from $1$ to $n$: $P_j$ (the static public key of participant $j$, in its standard encoding).
    6. For $j$ from $1$ to $n$: $C_j$ (the full VSS commitment of participant $j$: $C_{j,0} \parallel \cdots \parallel C_{j,t-1}$).
    7. For $j$ from $1$ to $n$: $PoP_j$ (the Proof of Possession signature from participant $j$).
    8. For $j$ from $1$ to $n$: $E_j$ (the ephemeral public key from participant $j$).

   All participants **MUST** produce identical transcripts. Any difference indicates a split-view attack or implementation bug.
2. **Sign Transcript:** Participant $i$ signs the transcript $T$ with their long-term static private key $d_i$,
   producing a signature $sig_i$.
3. **Broadcast Signature:** Participant $i$ sends $sig_i$ to the coordinator.
4. **Verify Certificate:** The coordinator broadcasts the set of all signatures ${sig_1, \cdots, sig_n}$ to everyone.
   Each participant $i$ verifies every signature $sig_j$ on the transcript $T$ against the public key $P_j$.
5. **Success:** If all signatures are valid, the DKG is successful. The participant stores their secret share $x_i$ and
   the group public key $Y$. The collection of $T$ and all $n$ signatures on it is called a "success certificate" and
   can be stored for auditing.

## Error Handling

A robust implementation of COCKTAIL-DKG **MUST** handle a variety of error conditions. Errors can arise from malformed
messages, invalid cryptographic values, or protocol violations. The ability to distinguish between these cases is
crucial for security and usability.

### Error Categories

We recommend that implementations define distinct error types to represent different failure modes. This allows
applications to react appropriately, whether by retrying an operation, aborting the protocol, or initiating a
blame-finding procedure.

The following categories cover the most common errors:

1. **Parsing and Deserialization Errors**:
    - **Description**: These errors occur when a received message does not conform to the byte-based format specified in
      the `Message Formats` section. This could be due to an incorrect length, an invalid point or scalar encoding, or
      other structural defects.
    - **Action**: An honest participant should never produce a malformed message. If a participant receives such a
      message, it should be treated as evidence of a bug in the sender's implementation or a deliberate protocol
      violation. The protocol **MUST** be aborted. If the sender can be identified (e.g., in $msg_{1|i}$), they should
      be flagged as faulty.
2. **Cryptographic Verification Failures**:
    - **Description**: These errors occur when a cryptographic check fails. This category includes:
        - An invalid Proof-of-Possession ($PoP_j$).
        - A VSS share verification failure ($s_{j,i}G \ne \sum_{i}^{k} C_{j,k}$).
        - A failed decryption of an encrypted share ($c_{j,i}$).
        - An invalid signature on the final transcript ($sig_j$).
    - **Action**: A cryptographic failure is a clear indication that a participant is behaving maliciously or has a
      serious bug. The protocol **MUST** be aborted immediately. The participant who sent the invalid data **MUST** be
      identified and blamed. For example, if $PoP_j$ is invalid, participant $j$ is at fault.
3. **Protocol Logic Errors**:
    - **Description**: These errors relate to violations of the protocol's state machine or rules, such as:
        - A participant sending a message at the wrong time.
        - The coordinator broadcasting an inconsistent `msg2` (e.g., omitting a participant's data).
    - **Action**: These errors indicate a faulty participant or coordinator. The protocol **MUST** be aborted.
      If the error can be traced to a specific participant, they should be blamed.

### Blame-Finding and Reporting

A key feature of a secure DKG protocol is the ability to identify malicious participants. When an error occurs, the
protocol **MUST** not only terminate but also output information about who caused the failure. This is crucial for
accountability in decentralized systems.

- **Coordinator's Role**: The coordinator is in a unique position to detect errors in $msg_{1|i}$ messages. If the
  coordinator receives a malformed message or one with an invalid PoP from participant $i$, it **MUST** immediately abort
  the protocol and broadcast a blame message identifying participant $i$ as faulty, including the malformed message as
  evidence.
- **Participant's Role and Public Proofs**: Participants **MUST** validate all data they receive.
  - If participant $i$ fails to verify a share $s_{j,i}$ from participant $j$, it **MUST** abort. To prove that $j$
    is cheating, participant $i$ can broadcast a blame message containing $j$'s index and the invalid share $s_{j,i}$.
    Any third party can then verify this claim by checking the VSS equation 
    ($s_{j,i} \cdot B = \sum_{k=0}^{t-1} i^k \cdot C_{j,k}$)
    using the public commitment $C_j$. A failure of this equation is a public and undeniable proof of $j$'s misbehavior.
  - Similarly, if a PoP from participant $j$ is invalid, this is also a publicly verifiable proof of misbehavior,
    since the PoP, the message it signs, and the public key $C_{j,0}$ are all public.
- **Resolving Disputes and Coordinator Malice**: The final certification round is essential for detecting a malicious
  coordinator and resolving disputes.
  - **Split-View Attack**: If a coordinator sends different messages to different participants, their final
    transcripts $T$ will differ. In Round 3, when participants exchange signatures, these signatures will not verify
    on the inconsistent transcripts.
    An honest participant $i$ who fails to verify $sig_j$ can initiate a dispute by broadcasting their $T_i$ and $sig_i$.
    - If participant $j$ responds with a different $T_j$ and a valid $sig_j$ over it, the discrepancy between $T_i$ and
      $T_j$ serves as undeniable proof of a split-view attack by the coordinator.
  - **Framing a Participant**: If a coordinator attempts to frame participant $j$ by modifying their $msg_{1|j}$ before
    broadcasting it, the PoP will fail for all other participants, who will blame $j$. However, in Round 3,
    participant $j$ will construct a transcript based on their *original*, valid $msg_{1|j}$. Their signature $sig_j$
    will be valid for their transcript but not for the altered transcript held by others. When this signature
    mismatch is detected, participant $j$ can reveal their original $msg_{1|j}$ (with its valid PoP) and their 
    transcript signature. This evidence proves their honesty and definitively identifies the coordinator as malicious.

## Ciphersuites

This section describes the ciphersuites that are specified for use with COCKTAIL. The current scope includes both
[RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-ciphersuites) and [ZIP-0312](https://zips.z.cash/zip-0312#ciphersuites).

Each ciphersuite defines a key derivation function $H6(x, pk1, pk2, extra)$, an encryption method $Enc(plain, key, iv)$,
and a decryption method $Dec(cipher, key, iv)$. Ciphersuites **SHOULD** use an AEAD mode for $Enc()$ and $Dec()$.

The choice of AEAD is guided by the principle of preventing nonce reuse. For ciphersuites where the underlying hash
function provides a large enough output (at least 480 bits; e.g., SHA-512), we can derive both the 256-bit key and a 
24-byte (192-bit) nonce (which is long enough to be generated randomly with a negligible chance of collision).

For ciphersuites based on SHA-256, where the output is smaller than 480 bits, we use $H6()$ to derive an Input Keying
Material (IKM), which is then used with the underlying hash function with two different prefixes. For the key, we use
$Sha256("COCKTAIL-derive-key" \parallel ikm)$. For the nonce, we use the most significant 192 bits of 
$Sha256("COCKTAIL-derive-nonce" \parallel ikm)$. The AEAD of choice for the SHA-256 based ciphersuites we specify here is
[XAES-256-GCM](https://github.com/C2SP/C2SP/blob/main/XAES-256-GCM.md).

The $H6$ function is used to derive a symmetric key and nonce from ECDH shared secrets. Unless otherwise specified,
it is defined as:

$H6(x, E, P_s, P_r, extra) = CH(prefix \parallel x \parallel E \parallel P_s \parallel P_r \parallel len(extra) \parallel extra)$

- $CH$: The specified cryptographic hash function (e.g., SHA-512, BLAKE2b-512).
- $prefix$: A ciphersuite-specific byte string (e.g., `COCKTAIL-DKG-Ed25519-SHA512-H6`).
- $x$: The concatenation of two ECDH shared secrets: $S^{(e)}$ (ephemeral-to-static) and $S^{(d)}$ (static-to-static).
- $E$: The sender's ephemeral public key.
- $P_s$: The sender's static public key.
- $P_r$: The recipient's static public key.
- $len(extra)$: The length of the `extra` data, encoded as a little-endian 64-bit integer.
- $extra$: Additional context-specific data.

The output of $H6$ is used to derive the key and nonce for the AEAD.

### Ciphersuite Definitions

- **COCKTAIL(Ed25519, SHA-512)**
  - **`H6` Hash**: SHA-512
  - **`H6` Prefix**: `COCKTAIL-DKG-Ed25519-SHA512-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(Ristretto255, SHA-512)**
  - **`H6` Hash**: SHA-512
  - **`H6` Prefix**: `COCKTAIL-DKG-Ristretto255-SHA512-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(Ed448, SHAKE256)**
  - **`H6` Hash**: SHAKE256 (with a 56-byte output)
  - **`H6` Prefix**: `COCKTAIL-DKG-Ed448-SHAKE256-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(P-256, SHA-256)**
  - **`H6` Hash**: SHA-256
  - **`H6` Prefix**: `COCKTAIL-DKG-P256-SHA256-H6`
  - **Key/Nonce**: The output of `H6` is used as an input key material.
    - The key shall the SHA256 of the string `COCKTAIL-derive-key` followed by the IKM.
    - The nonce shall the first 24 bytes SHA256 of the string `COCKTAIL-derive-nonce` followed by the IKM.
  - **AEAD**: [XAES-256-GCM](https://github.com/C2SP/C2SP/blob/main/XAES-256-GCM.md)

- **COCKTAIL(secp256k1, SHA-256)**
  - **Note**: This ciphersuite is **NOT** backwards-compatible with ChillDKG due to our key derivation including both
    ephemeral-static and static-static ECDH, instead of just ephemeral-static (see 
    [Differences from ChillDKG](#differences-from-chilldkg) below).
  - **`H6` Definition**: A BIP-340-style tagged hash with the tag `COCKTAIL-DKG/H6`.
    The message is $x \parallel E \parallel P_s \parallel P_r \parallel extra$.
  - **Key/Nonce**: The output of `H6` is used as an input key material.
    - The key shall the SHA256 of the string `COCKTAIL-derive-key` followed by the IKM.
    - The nonce shall the first 24 bytes SHA256 of the string `COCKTAIL-derive-nonce` followed by the IKM.
  - **AEAD**: [XAES-256-GCM](https://github.com/C2SP/C2SP/blob/main/XAES-256-GCM.md)
  - **Bitcoin Taproot Warning**: When using this ciphersuite for Bitcoin Taproot outputs, applications **MUST** be aware
    that a malicious participant could attempt to embed a hidden Taproot script path commitment in the threshold public
    key. Applications intending to use the group public key $Y$ as a Taproot output **SHOULD** apply an additional
    unspendable script path tweak (as described in ChillDKG) or use the key only for key-path spending with appropriate
    safeguards. This consideration is specific to Bitcoin Taproot and does not apply to other uses of this ciphersuite.

- **COCKTAIL(JubJub, BLAKE2b-512)**
  - **Note**: Compatible with [ZIP-0312](https://zips.z.cash/zip-0312#ciphersuites).
  - **`H6` Hash**: BLAKE2b-512 (with a 56-byte output)
  - **`H6` Prefix**: `COCKTAIL-DKG-JubJub-BLAKE2b-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(Pallas, BLAKE2b-512)**
  - **Note**: Compatible with [ZIP-0312](https://zips.z.cash/zip-0312#ciphersuites).
  - **`H6` Hash**: BLAKE2b-512 (with a 56-byte output)
  - **`H6` Prefix**: `COCKTAIL-DKG-Pallas-BLAKE2b-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

### Schnorr Signature Scheme

COCKTAIL-DKG uses a simple Schnorr signature scheme for both the Proof of Possession (PoP) and the transcript 
certification in Round 3. The signature scheme is defined as follows:

#### Schnorr Signature Format

A signature consists of two components:

- $R$: A compressed elliptic curve point (the commitment)
- $z$: A scalar (the response)

The signature is encoded as the concatenation of the compressed point encoding of $R$ followed by the scalar encoding 
of $z$. The total signature size is the point size plus the scalar size (e.g., 64 bytes for Ristretto255/Ed25519, 65 
bytes for P-256/secp256k1).

#### Schnorr Sign Algorithm (Prove Possession)

Given a secret key $sk$ (a scalar) and a message $m$ (a byte string):

1. Compute the public key: $pk = sk * B$
2. Compute a deterministic nonce: $k = H(sk \parallel m)$ reduced to a scalar
3. Compute the commitment: $R = k * B$
4. Compute the challenge: $c = H(R \parallel pk \parallel m)$ reduced to a scalar
5. Compute the response: $z = k + c * sk$
6. Return the signature $(R, z)$

Where:

- $H$ is the ciphersuite's hash function (SHA-512 for Ed25519/Ristretto255, SHA-256 for P-256/secp256k1)
- The hash output is reduced to a scalar using wide reduction (mod $q$) for 64-byte hashes, or direct reduction for 32-byte hashes
- $B$ is the generator point of the elliptic curve group

#### Schnorr Verify Algorithm (Verify Proof of Possession)

Given a signature $(R, z)$, a public key $pk$, and a message $m$:

1. Compute the challenge: $c = H(R \parallel pk \parallel m)$ reduced to a scalar
2. Compute the left-hand side: $lhs = z * B$
3. Compute the right-hand side: $rhs = R + c * pk$
4. Return `true` if $lhs = rhs$, otherwise return `false`

#### Schnorr Hash-to-Scalar Reduction

For ciphersuites using SHA-512 (Ed25519, Ristretto255), the 64-byte hash output is reduced to a scalar using
wide modular reduction (reducing a 512-bit integer modulo the group order $q$).

For ciphersuites using SHA-256 (P-256, secp256k1), the 32-byte hash output is reduced to a scalar by interpreting
the hash as a big-endian integer and reducing modulo the group order $q$.

#### Schnorr Security Notes

- The deterministic nonce generation ($k = H(sk \parallel m)$) prevents nonce-reuse attacks that would leak the 
  secret key.
- The challenge includes $R$, $pk$, and the full message, binding the signature to all inputs.
- This signature scheme is NOT the same as EdDSA (RFC 8032), ECDSA, or BIP-340. Implementations **MUST** use the
  scheme specified here to ensure interoperability with COCKTAIL-DKG.

## Security Considerations

- **Coordinator Role**: The coordinator is trusted for availability and to correctly broadcast messages, but is not
  trusted with the confidentiality of any secret data. A malicious coordinator can disrupt the protocol by refusing to
  broadcast messages or by sending different messages to different participants, but it cannot learn the secret shares
  or the final group secret key. The final certification round (Round 3) is designed to detect such split-view attacks.
- **Proof of Possession (PoP)**: The PoP in Round 1 prevents a malicious participant from performing a rogue key attack.
  By signing their commitment $C_{i,0}$ with the corresponding secret $a_{i,0}$, each participant proves they actually
  know the secret key they are contributing. Without this, an attacker could contribute a public key for which they
  don't know the private key, leading to an unusable group key. The PoP message includes the context string (which
  contains all participant public keys), the full VSS commitment $C_i$, and the ephemeral key $E_i$. The participant
  index $i$ is not explicitly included in the PoP message because it is implicitly bound through the context string
  (which includes all $P_j$) and through the position of the message in the broadcast.
- **Verifiable Secret Sharing (VSS)**: Feldman's VSS scheme ensures that even if a participant is malicious and sends
  incorrect shares, they will be caught. The VSS verification check in Round 2 (step 3.4) allows each participant to
  verify that the share they received is consistent with the public commitment. This prevents a malicious participant
  from corrupting the final key.
  - Participant IDs ($i$, $j$, etc.) **MUST NOT** be equal to 0 or a multiple of the elliptic curve group order.
    Respecting this requirement prevents a [zero share attack](https://www.zkdocs.com/docs/zkdocs/protocol-primitives/verifiable-secret-sharing/).
- **Encryption of Shares**: The use of an AEAD to encrypt the secret shares $s_{i,j}$ is crucial. It provides
  confidentiality against an eavesdropper on the communication channel and authenticity to prevent a man-in-the-middle
  from tampering with the shares. The encryption key is derived using two ECDH shared secrets: one from the sender's
  ephemeral key with the recipient's static key ($S^{(e)}_{i,j} = e_i * P_j$), and one from the sender's static key
  with the recipient's static key ($S^{(d)}_{i,j} = d_i * P_j$). This approach provides:
  - **Forward secrecy**: Compromise of long-term keys does not reveal past session secrets, due to the ephemeral 
    component.
  - **Robust blame-finding**: If decryption fails, the recipient can prove the sender misbehaved using only public
    information. Since both parties can independently compute both ECDH shared secrets (the recipient computes
    $d_i * E_j$ and $d_i * P_j$), a third party with access to the sender's public keys $E_j$ and $P_j$ can verify
    blame claims without requiring the recipient to reveal their private key.
  - **Sender authentication**: The inclusion of the static-to-static ECDH binds the ciphertext to the sender's identity,
    preventing an attacker from replaying or modifying ciphertexts without detection.
- **Cofactor Security**: As noted in the [working with curves with small subgroups](#working-with-curves-with-small-subgroups)
  section, curves like Ed25519 and Ed448 have small cofactors. It is critical that implementations use prime-order group
  abstractions like Ristretto255 and Decaf448 to prevent small subgroup attacks, where an attacker could submit a 
  low-order point to leak information.
- **Participant Authentication**: Throughout the protocol, participants are authenticated to each other via their
  long-term static key pairs. The pairwise ECDH key agreement used to encrypt shares in Round 1 provides deniable
  authentication; only the owner of the corresponding static private key can derive the correct symmetric key to decrypt
  and verify the secret share. This ensures that participants are communicating with the intended parties. The final
  signature on the transcript in Round 3 provides explicit, non-repudiable authentication of each participant's agreement
  on the final public state.
- **Transcript Certification**: The final round where all participants sign the public transcript is vital. It ensures
  that all honest participants have a consistent view of the entire public state of the DKG. If a malicious coordinator
  tried to give different participants different sets of messages, the transcript signatures would not match, and the
  protocol would fail safely. This provides a guarantee of explicit consensus. Notably, COCKTAIL-DKG does not require
  an honest majority for security: even a single honest participant will detect a split-view attack. The success
  certificate (transcript plus all signatures) serves as cryptographic proof that all participants agreed on the same
  public state at protocol completion.

### Working with curves with small subgroups

Certain elliptic curves used in cryptography are in the so-called Montgomery or Edwards model, picked for particularly
efficient arithmetic. The downside to these curves is that they have an order which factors as $n = [h] * q$ for some
small value $h$ and large prime $q$. If an attacker can select a point $P$ of order $h$ they can potentially leak
partial information about the secret scalars from the output of $[s] P$. (They specifically learn $s \bmod h$).

Two curves in these families we consider are ed25519 with $h = 8$ and edwards448 with $h = 4$. When these curves are
required, use the safe abstractions (Ristretto255 and Decaf448 respectively) which internally handle cofactor clearing.

However, for some use cases, ed25519 and edwards448 might be used directly. Here, users MUST ensure all points are in
the prime order subgroup q through proper cofactor clearing.

In the case that a protocol requires both the abstractions (Ristretto255 and Decaf448) as well as points on the curves
themselves, then the lifted points must have their potential cofactors cleared. This should be done by computing
$P^{\prime} = [1/h] [h] P$ where $P$ is a point in the group abstraction. The point $P^{\prime}$ can then be safely
used on the curve itself as it will either be a point of order q or when P is the point at infinity, then $P^{\prime}$
will be too.

### Optional Application Payloads

COCKTAIL-DKG supports an optional application-defined payload that can be included alongside each secret share in the
encrypted ciphertext. This feature enables applications to derive additional shared secrets during the DKG without
running a separate protocol.

**Use Cases:**

- **Backup encryption keys**: Participants can exchange random contributions to derive a shared backup key.
- **Session keys**: Applications can establish pairwise or group session keys for subsequent communication.
- **Application-specific data**: Any data that needs to be securely exchanged between participants during key generation.

**Payload Format:**

The plaintext encrypted in each ciphertext $c_{i,j}$ has the format:
$plaintext_{i,j} = s_{i,j} \parallel payload_{i,j}$

Where $s_{i,j}$ is the fixed-size secret share (determined by the scalar size of the ciphersuite) and $payload_{i,j}$
is the variable-length application payload (which may be empty).

**Payload Commitments:**

If applications use payloads and need to ensure all participants agree on the payloads exchanged, they **SHOULD**
include commitments to the payloads in the transcript or in application-specific extension data. A recommended
commitment format is:
$commitment = H(len(payload) \parallel payload)$

Where $len(payload)$ is the length of the payload encoded as a little-endian 64-bit integer. This format ensures
domain separation between payloads of different lengths.

**Security Note:**

The optional payload is encrypted and authenticated by the same AEAD that protects the secret share. However, the
payload is NOT verified against the VSS commitments (only the share portion is). Applications using payloads **MUST**
implement their own verification logic if payload integrity beyond AEAD authentication is required.

### Differences from ChillDKG

COCKTAIL-DKG is derived from [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg) but introduces several
important changes that break backwards compatibility:

#### 1. Key Derivation Uses Both Static and Ephemeral ECDH

ChillDKG derives encryption keys using only an ephemeral-to-static ECDH:

$S_{i,j} = e_i * P_j$

COCKTAIL-DKG uses both ephemeral-to-static AND static-to-static ECDH:

$S^{(e)}_{i,j} = e_i * P_j$ and $S^{(d)}_{i,j} = d_i * P_j$

**Why this matters:**

Our approach significantly improves blame-finding when decryption fails. 

With ChillDKG's ephemeral-only approach, if participant $i$ claims that participant $j$'s ciphertext failed to decrypt,
proving this claim requires $i$ to demonstrate they correctly computed the ECDH shared secret. However, since only $j$
knows the ephemeral secret $e_j$, participant $i$ cannot prove to a third party that they used the correct shared secret
without revealing their own long-term private key $d_i$.

With COCKTAIL-DKG's  approach, the encryption key depends on both parties' long-term public keys, which are
publicly known. A third party can verify that participant $i$ correctly derived the key by checking that:

- The ephemeral component matches: $d_i * E_j$ (verifiable if $i$ reveals the result)
- The static component matches: This is deterministic from public keys $P_i$ and $P_j$

This enables more robust blame attribution without requiring participants to reveal their long-term secrets.

#### 2. Extended H6 Function

The H6 key derivation function now includes the sender's static public key $P_s$ in addition to the recipient's
public key $P_r$: $H6(x, E, P_s, P_r, extra)$ instead of $H6(x, E, P_r, extra)$.

#### 3. Optional Application Payloads

COCKTAIL-DKG allows optional application-defined data to be included in the encrypted share ciphertexts, which
ChillDKG does not support.

## Alternatives

- **Trusted Dealer**: Simpler but introduces a single point of failure. COCKTAIL-DKG is for scenarios where a trusted
  dealer is unavailable or undesirable.
- **Original FROST DKG**: Requires pre-established secure channels between all participant pairs. COCKTAIL-DKG builds
  in its own encryption layer (EncPedPop), making it usable over insecure channels.

## Appendix A: Pseudocode

This appendix provides a series of algorithms that describe the COCKTAIL-DKG protocol in a high-level,
implementation-agnostic manner. The notation is meant to be illustrative rather than strictly formal.

### Algorithm 1: Polynomial Generation and VSS Commitment

**Input:**

- `t`: The threshold parameter.
- `G`: The generator point of the elliptic curve group.
- `q`: The order of the elliptic curve group.

**Output:**

- `f`: A secret polynomial of degree `t-1`.
- `C`: A vector of public commitments to the polynomial coefficients.

**Steps:**

1. Initialize an empty polynomial f.
2. Initialize an empty list of commitments C.
3. For k from 0 to t-1:
    1. Generate a random scalar a_k in the range [0, q-1].
    2. Add the term a_k * x^k to the polynomial f.
    3. Compute the commitment C_k = a_k * B.
    4. Append C_k to the list C.
4. Return (f, C).

**Pseudocode:**

```python
function GeneratePolynomial(t, G, q):
    f = new Polynomial()
    C = new List<Point>()

    for k from 0 to t-1:
        a_k = RandomScalar(q)
        f.add_coefficient(a_k)

        C_k = a_k * B
        C.append(C_k)

    return (f, C)
```

---

### Algorithm 2: Secret Share Evaluation

**Input:**

- `f`: A secret polynomial.
- `j`: The index of the recipient participant.

**Output:**

- `s_j`: The secret share for participant `j`.

**Steps:**

1. Evaluate the polynomial f at the point x = j.
2. Let the result be s_j = f(j).
3. Return s_j.

**Pseudocode:**

```python
function EvaluatePolynomial(f, j):
    result = 0
    # iterate from highest degree to lowest
    for a in reverse(f.coefficients):
        result = result * j + a
    return result
```

---

### Algorithm 3: Secret Share Verification

**Input:**

- `s_j`: A secret share received from another participant.
- `j`: The index of the recipient participant (i.e., self).
- `C`: The list of VSS commitments from the sender.
- `G`: The generator point of the elliptic curve group.
- `t`: The threshold parameter.

**Output:**

- `valid`: A boolean indicating if the share is valid.

**Steps:**

1. Compute the public verification point from the share: V = s_j * B.
2. Compute the expected verification point from the commitments:
    1. Initialize an identity point R.
    2. For k from 0 to t-1:
        1. Compute term = (j^k) * C_k.
        2. Add term to R: R = R + term.
3. Compare the points: valid = (V == R).
4. Return valid.

**Pseudocode:**

```python
function VerifyShare(s_ji, i, C_j, G, t):
    # V = s_{j,i} * B
    V = s_ji * B

    # R = sum_{k=0}^{t-1} (i^k * C_{j,k})
    R = IdentityPoint()
    for k from 0 to t-1:
        i_k = power(i, k)
        C_jk = C_j[k]
        term = i_k * C_jk
        R = R + term

    return V == R
```

### Helper: Key and Nonce Derivation

This helper abstracts the ciphersuite-dependent key derivation logic used in Rounds 1 and 2.

```python
function DeriveKeyAndNonce(cs, ecdh_secret, E, P_sender, P_recipient, context):
    if cs.HashFunction.OutputSizeInBytes() >= 56:
        tmp = H6(ecdh_secret, E, P_sender, P_recipient, context)
        return (tmp[0:32], tmp[32:56])
    else:
        ikm = H6(ecdh_secret, E, P_sender, P_recipient, context)
        key = H("COCKTAIL-derive-key" || ikm)
        nonce = H("COCKTAIL-derive-nonce" || ikm)[0:24]
        return (key, nonce)
```

### Algorithm 4: COCKTAIL-DKG Round 1 (Participant `i`)

**Input:**

- `i`: The index of the current participant.
- `t`: The threshold parameter.
- `n`: The total number of participants.
- `cs`: The ciphersuite (providing Group, Hash, AEAD).
- `context`: A session-specific context string.
- `d_i`: The static private key of participant `i`.
- `P_i`: The static public key of participant `i`.
- `P_j`: The static public key of every other participant `j`.
- `payloads`: (Optional) A map from participant index `j` to application-defined payload bytes.

**Output:**

- `msg1_i`: The Round 1 message to be broadcast.
- `internal_state`: Values to be stored for the next round (e.g., polynomial, ephemeral key).

**Steps:**

1. Generate Polynomial and VSS Commitment:
    1. (f_i, C_i) = Algorithm1(t, cs.Group.G, cs.Group.q)
2. Generate Ephemeral Key:
    1. e_i = cs.Group.RandomScalar()
    2. E_i = e_i * cs.Group.G
3. Compute Proof of Possession (PoP):
    1. Let a_i_0 be the constant term of f_i.
    2. Let C_i_0 be the first commitment in C_i.
    3. PoP_i = Sign(private_key=a_i_0, message=context || C_i || E_i) (using a scheme compatible with C_i_0).
4. Compute and Encrypt Shares:
    1. Initialize an empty list encrypted_shares.
    2. For j from 1 to n:
        1. s_i_j = Algorithm2(f_i, j).
        2. Derive ECDH key using both ephemeral and static secrets:
            - ecdh_ephemeral = e_i * P_j
            - ecdh_static = d_i * P_j
            - ecdh_secret = ecdh_ephemeral || ecdh_static
            - If the hash function used has an output size fewer than 480 bits, use the output
              of H6 as an Input Keying Material to two more hash function calls, which will be used
              to derive a nonce and key. (Here, H() refers to, e.g., sha256):
              - ikm = H6(ecdh_secret, E_i, P_i, P_j, context)
              - key = H("COCKTAIL-derive-key" || ikm)
              - nonce = H("COCKTAIL-derive-nonce" || ikm)\[0:24]
            - If the hash function used has an output size greater than equal to 480 bits, just split them:
              - tmp = H6(ecdh_secret, E_i, P_i, P_j, context)
              - key = tmp[0:32] (32 bytes)
              - nonce = tmp[32:56] (24 bytes)
        3. Prepare plaintext with optional payload:
            - payload_i_j = payloads[j] if j in payloads else empty bytes
            - plaintext = s_i_j || payload_i_j
        4. Encrypt plaintext:
            - c_i_j = Encrypt(key, nonce, plaintext)
        5. Append c_i_j to encrypted_shares.
5. Construct Message:
    1. msg1_i = (C_i, PoP_i, E_i, encrypted_shares)
6. Store State:
    1. internal_state = (f_i, e_i)
7. Return (msg1_i, internal_state).

**Pseudocode:**

```python
function Round1(i, t, n, cs, context, d_i, P_i, AllPublicKeys, payloads={}):
    (f_i, C_i) = GeneratePolynomial(t, cs.Group.G, cs.Group.q)
    a_i0 = f_i.coefficient(0)
    e_i = cs.Group.RandomScalar()
    E_i = e_i * cs.Group.G
    PoP_i = Sign(private_key=a_i0, message=context || C_i || E_i)

    encrypted_shares = new List<Ciphertext>()
    for j from 1 to n:
        s_ij = EvaluatePolynomial(f_i, j)
        P_j = AllPublicKeys[j]
        ecdh_secret = (e_i * P_j) || (d_i * P_j)
        (key, nonce) = DeriveKeyAndNonce(cs, ecdh_secret, E_i, P_i, P_j, context)
        payload_ij = payloads.get(j, empty_bytes)
        c_ij = Encrypt(key, nonce, s_ij || payload_ij)
        encrypted_shares.append(c_ij)

    msg1_i = new Round1Message(C_i, PoP_i, E_i, encrypted_shares)
    internal_state = new State(f_i, e_i)
    return (msg1_i, internal_state)
```

### Algorithm 5: COCKTAIL-DKG Round 2 (Participant `i`)

**Input:**

- `i`: The index of the current participant.
- `all_msg1s`: A list of all Round 1 messages from all participants.
- `internal_state`: The state saved from Round 1 (`f_i`, `e_i`).
- `d_i`: The static private key of participant `i`.
- `P_i`: The static public key of participant `i`.
- `AllPublicKeys`: The static public keys of all participants.
- `cs`: The ciphersuite.
- `context`: The session-specific context string.

**Output:**

- `x_i`: The final secret share for participant `i`.
- `Y`: The group public key.
- `Y_i`: The public verification share for participant `i`.
- `received_payloads`: A map from participant index `j` to the received payload bytes (may be empty).
- `transcript_data`: Public data needed for Round 3.

**Steps:**

1. Initialize an empty list received_shares.
2. Initialize an empty map received_payloads.
3. Process messages from each participant j:
    1. For j from 1 to n:
        1. Parse (C_j, PoP_j, E_j, encrypted_shares_j) from msg1_j.
        2. Verify PoP:
            - valid_pop = Verify(public_key=C_j_0, signature=PoP_j, message=context || C_j || E_j)
            - If valid_pop is false, abort and blame participant j.
        3. Decrypt Plaintext:
            - Let c_j_i be the encrypted ciphertext from j for i.
            - Let P_j = AllPublicKeys\[j\].
            - Derive ECDH key using both ephemeral and static secrets:
                - ecdh_ephemeral = d_i * E_j
                - ecdh_static = d_i * P_j
                - ecdh_secret = ecdh_ephemeral || ecdh_static
                - If the hash function used has an output size fewer than 480 bits, use the output
                  of H6 as an Input Keying Material to two more hash function calls, which will be used
                  to derive a nonce and key. (Here, H() refers to, e.g., sha256):
                  - ikm = H6(ecdh_secret, E_j, P_j, P_i, context)
                  - key = H("COCKTAIL-derive-key" || ikm)
                  - nonce = H("COCKTAIL-derive-nonce" || ikm)\[0:24]
                - If the hash function used has an output size greater than equal to 480 bits, just split them:
                  - tmp = H6(ecdh_secret, E_j, P_j, P_i, context)
                  - key = tmp\[0:32\] (32 bytes)
                  - nonce = tmp\[32:56\] (24 bytes)
            - Decrypt:
                - plaintext = Decrypt(key, nonce, ciphertext=c_j_i)
                - If decryption fails, abort and blame participant j.
        4. Parse Plaintext:
            - s_j_i = plaintext\[0:scalar_size\] (the secret share)
            - payload_j_i = plaintext\[scalar_size:\] (any remaining bytes are the optional payload)
            - received_payloads\[j\] = payload_j_i
        5. Verify Share:
            - valid_share = Algorithm3(s_j_i, i, C_j, cs.Group.G, t)
            - If valid_share is false, abort and blame participant j.
        6. Add s_j_i to received_shares.
4. Compute Final Keys:
    1. x_i = sum(received_shares) (scalar addition).
    2. Y = sum(C_j_0 for all j) (point addition).
    3. Compute Verification Share Y_i:
        1. Initialize Y_i to the identity point.
        2. For k from 0 to t-1:
            - C_agg_k = sum(C_j_k for all j) (point addition).
            - term = (i^k) * C_agg_k
            - Y_i = Y_i + term
    4. Final Check:
        - If x_i * cs.Group.G != Y_i, abort (protocol failure).
5. Prepare for Round 3:
    1. transcript_data = (all_msg1s, context, all_static_public_keys)
6. Return (x_i, Y, Y_i, received_payloads, transcript_data).

**Pseudocode:**

```python
function Round2(i, all_msg1s, internal_state, d_i, P_i, AllPublicKeys, cs, context):
    received_shares = new List<Scalar>()
    received_payloads = new Map<int, bytes>()

    for j from 1 to n:
        msg1_j = all_msg1s[j]
        C_j, PoP_j, E_j = msg1_j.C, msg1_j.PoP, msg1_j.E
        P_j = AllPublicKeys[j]

        if len(C_j) != t:
            abort("Invalid commitment length", j)
        if not Verify(public_key=C_j[0], signature=PoP_j, message=context || C_j || E_j):
            abort("Invalid PoP", j)

        c_ji = msg1_j.encrypted_shares[i]
        ecdh_secret = (d_i * E_j) || (d_i * P_j)
        (key, nonce) = DeriveKeyAndNonce(cs, ecdh_secret, E_j, P_j, P_i, context)
        plaintext = Decrypt(key, nonce, ciphertext=c_ji)
        if plaintext is null:
            abort("Decryption failed", j)

        s_ji = plaintext[0:scalar_size]
        received_payloads[j] = plaintext[scalar_size:]

        if not VerifyShare(s_ji, i, C_j, cs.Group.G, t):
            abort("Invalid share", j)
        received_shares.append(s_ji)

    x_i = sum(received_shares)
    Y = sum(all_msg1s[j].C[0] for j in 1..n)
    Y_i = IdentityPoint()
    for k from 0 to t-1:
        C_agg_k = sum(all_msg1s[j].C[k] for j in 1..n)
        Y_i = Y_i + (power(i, k) * C_agg_k)

    if (x_i * cs.Group.G) != Y_i:
        abort("Final check failed")

    transcript_data = new TranscriptData(all_msg1s, context, AllPublicKeys)
    return (x_i, Y, Y_i, received_payloads, transcript_data)
```

### Algorithm 6: COCKTAIL-DKG Round 3 (Participant `i`)

**Input:**

- `i`: The index of the current participant.
- `d_i`: The static private key of participant `i`.
- `P_j`: The static public key of every other participant `j`.
- `transcript_data`: The public data from Round 2.

**Output:**

- `success`: A boolean indicating the protocol completed successfully.

**Steps:**

1. Construct Transcript:
    1. T = CanonicalEncode(transcript_data)
2. Sign Transcript:
    1. sig_i = Sign(private_key=d_i, message=T)
3. Broadcast and Receive Signatures:
    1. Send sig_i to the coordinator.
    2. Receive all_signatures from the coordinator.
4. Verify All Signatures:
    1. For j from 1 to n:
        1. Let sig_j be the signature from participant j.
        2. valid_sig = Verify(public_key=P_j, signature=sig_j, message=T)
        3. If valid_sig is false, abort and blame participant j.
5. Success:
    1. success = true
6. Return success.

**Pseudocode:**

```python
function Round3(i, d_i, AllPublicKeys, transcript_data):
    T = CanonicalEncode(transcript_data)
    sig_i = Sign(private_key=d_i, message=T)
    all_signatures = broadcast_and_receive(sig_i)

    for j from 1 to n:
        if not Verify(public_key=AllPublicKeys[j], signature=all_signatures[j], message=T):
            abort("Invalid transcript signature", j)

    return true
```

## Appendix B: Test Vectors

This section provides a set of test vectors for a 2-of-3 DKG for various ciphersuites.
The vectors were generated deterministically using a seed derived from the authors' names:

```
seed = SHA256("Daniel Bourdrez,Soatok Dreamseeker,Tjaden Hess")
     = b171b6992cc6db1f40b18dd8b1361d642f013e4b1208a735259a516af60dcb68
```

### Transparent Derivation Scheme

All secret values are derived using a labeled hash with ciphersuite domain separation:

```
derived_bytes = H(seed || ciphersuite_id || label)
```

Where:

- `H` is the ciphersuite's hash function (e.g., SHA-512 for Ristretto255, SHA-256 for P-256)
- `ciphersuite_id` is the ciphersuite identifier string (e.g., "COCKTAIL(Ristretto255, SHA-512)")
- `label` is a human-readable ASCII string identifying the value being derived

#### Labels

| Value | Label Format | Example |
|-------|-------------|---------|
| Static secret key for participant i | `static_secret_key_{i}` | `static_secret_key_1` |
| Round 1 RNG stream for participant i | `round1_participant_{i}` | `round1_participant_1` |

#### Scalar Reduction

For ciphersuites with 32-byte scalars and SHA-256 hash (P-256, secp256k1):

- The 32-byte hash output is reduced modulo the group order

For ciphersuites with 64-byte hash output (SHA-512, SHAKE256, BLAKE2b-512):

- Wide reduction is used (64 bytes reduced modulo the group order)

This allows any developer to independently reproduce the test vectors by:

1. Computing `H(seed || ciphersuite_id || label)` for each value
2. Reducing the hash output to a scalar using the appropriate method

The context string for all test vectors is:
```
"COCKTAIL-DKG-TEST-VECTOR-2-OF-3" (hex: 434f434b5441494c2d444b472d544553542d564543544f522d322d4f462d33)
```

Full test vectors in JSON format are available in the [cocktail-dkg/](cocktail-dkg/) directory.

### COCKTAIL(Ristretto255, SHA-512)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `1b0b02a6d05dbeea91c34c09727bc4a86934a0e5b937302a7e06b733cf04aa0d` | `5e10e4f9191dfaebaedad4a8c44611227b23f6b8a1fd90ac2e4c439ad1e0f530` |
| 2 | `bd88b358ebcb722d1ddb1d22f9f0978896586a2e64a07e5d142440dfde534703` | `60954df80383ef39d1d74a00046df4988f71926a72d7805e6bbce3b02a72ca43` |
| 3 | `e23339da2f526f32b09853907a6e88b052dfacdb64bd7d6b1a304f0178537a0e` | `f445dbc3514c533f8461c8a590513c71def9db543ecb42cab6c18c9bf2ab1603` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `34e7bfedbf8bb046117fab4814decbeedd7bfa901dd295c504efd7d78f5db304` | `a21204f03b202ce99cb1b0ea5a40fbe0a4602490eec1ddad5ea43eafcb1c374e` |
| 2 | `fb23d7ce8232460d755858a3749269c0b89a5597d859b3fd2a08ee0e50110d04` | `ec42aa1f69b06578590e89750b70625f193bd97f554dc75be0c05f398ffaad47` |
| 3 | `c260eeaf45d9dbd3d83105fed446079293b9b09d93e1d0355121044610c56603` | `b0a218b1ee612ab6a541d75d788f57e3156dc144165ecbc85c4c533e2386bd40` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `50dfd8cac7edd751e5aa748d5506949723939e965982d2ca13b56adb6512c6f2c311e5c45fb8c783c02ad6ba8c99233094fbf347711591077e88a798c6b5217f`

#### Final Output

- **Group Public Key**: `2635bccd836246119187424486f0943d2dc3f6c88cb4693604496b03fde19511`

### COCKTAIL(Ed25519, SHA-512)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `cb7d66d274b9f7c68799bd014e94bffc4ab2370cc37324e6caeea236eb10f608` | `305b7e49602cf880239f73889aca2f02949de5caab7887cf4be7333824dbf4a2` |
| 2 | `1893c61c506918c7197475a60d17b6e10479c9cbf6976085d06bc8bb7f648d02` | `8a5cce577f2ea7d1a5c3cd177658943dc6f262df0ced60724308aa79045b0a12` |
| 3 | `3a51c9a4eb2a7a487647d8ec6a2763f415cda6a4d38996a1079819c7c845b300` | `ce7677bcef4ae6b3e0a46db45bdb13997d900b64fb9172781e8935eaa7f0f899` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `0f6ac06d86c23448dd09c6c52d3a4ba59970c92e020db4e84d5af6604874eb01` | `ec3252ae4048d562194fad35f732e40e309b02d3f8e75c7a34f87240f2691792` |
| 2 | `0b1bf10a6f30b320d9479c219f59de30f5066346512369387134c1d626c11904` | `b5897d6024513ef34b2f139e3cab0e601eedd0a1bc50d5314946e8e4ce5d45ba` |
| 3 | `07cc21a8579e31f9d485727d107971bc509dfc5da0391e88940e8c4c050e4806` | `bb7a42d7a9be00e293acfbf6e84345b1bea1e3fd0e0a35c1f02c82dda28b64a2` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `e90521cc6e735e921665b6f8aa68e082d49e20432e291867377d8755835c56f7d105fa3f1b10db6a3ff257982afd661ed23595d9bbcd37c72ed87ef272a82196`

#### Final Output

- **Group Public Key**: `962e7ef6e114c47d3e83914d492f561de12901bd60543066ca0aaf913b4b9866`

### COCKTAIL(P-256, SHA-256)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `9719123dd1cabebb1e0d118b493a34ebb053110d387f64919925104780ff8505` | `03346abbfc2e415732058c80744307268c2451cd13fa2a3360c131dfecdc9fa737` |
| 2 | `7a89b37b07ab1cb3d0f179c3b9c83408dfea7e8c9428487b4e7a3235e5d41821` | `0325446b10d584a916cbd9b72f0732c28972747ee67778373b2ae533ba063f55db` |
| 3 | `89b0c366ffe3ebee1c2b4a3c5001e902bc207248facc0f73f9d059d1a1e5f572` | `02a5b832527d99bb24d9a5255e3ded9dee6c73c2b98250d41f81f9d1a1668156fe` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `e8db39168cff00ec7dc47ec0be33bc0aa7790301d75eb7891487887e67991ad6` | `02ea020dd7fac2a3801e82641cf0fb559943ff0563f8b3d3cd0f7c9961abd722ab` |
| 2 | `5a8e0dfc7a11ed83fd4b875886f6683b55adfa39a68e602bafdba70112bf930b` | `024d90ca889bc79aeea44e9115e2aa5acdacab58b2cfad249412da018fa1efb7a7` |
| 3 | `cc40e2e16724da1c7cd28ff04fb9146bc0c9ec1f1cd5a7533ee99046ba493091` | `02bdb57fc926e05ced2b0421ab88511f0732ecbb6e1bb8fa976a978abc825004bb` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `7bee57f3ce91eb7d13752a25aa017a54a65fc0803f753143e25bc8112043bec7`

#### Final Output

- **Group Public Key**: `03c1afa53ef809dfe48bd233a90c60410d0cc782fd34dd516ce47440bbb6c3e166`

### COCKTAIL(secp256k1, SHA-256)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `9b4dcb06ba195df2ebde865f907283e3260f3b7a1ef3d848d9cd373cb905bd4c` | `0349feb6371f5e59cd0ab4de76a529d1f406d12b31a51ba99a8c0aa6f2f8c9816c` |
| 2 | `a4f81dbe8f48fb1762080504007bfa438e93b65b5d6cc89585d6ec3296d19e98` | `03e5466e45ab0379298586bdb53a389bd699c099d0aabbefcabec61d3efaf64518` |
| 3 | `8fdb2a0957f21e5ef1df206379db8d2d55d6c36e1af5ad9babd5715843b40388` | `02c89ad54b3b89714645839036094d8e400ab90d745b63cadcf7b299bd224a688c` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `ca1c5789d2107aa67b21977c5e354ac08526fdc59f0fefd8b96141d3d1f4d00b` | `03dd3b021a9af82a7e8b0a09a794ffa0bd73dc2f867a95199337242ce738031151` |
| 2 | `84714fdacb02565f52c560f269613a6c8519dd792df04abab72b73eac91f99cd` | `030e352fb6318e7381d3849905122a3db6ed523754b6b3c1ba296b2bc2a444ab83` |
| 3 | `3ec6482bc3f432182a692a68748d2a18850cbd2cbcd0a59cb4f5a601c04a638f` | `0256e021448f64209b5146d0dbc0a7e23bc0598bc0a442645d3275e60895b1aafc` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `b1f4815c4d06bc82006436f831c1b95eb45c575e298b93b34a41f37b763e1d63`

#### Final Output

- **Group Public Key**: `03680a2bab113654989b6a1ca2aea61806c2ed10a005457f7501deb35a4f5756df`

### COCKTAIL(Ed448, SHAKE256)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `dfeea4c3d11ef8c2444ddc057ca43403ea12caf511869efe5151e2884d72ee665e839958cf9cfe236a343f3c4d607448f6ca9ac371558536` | `87aa3c8fbcd56eff0ebe252cd138aa884804267063c11415271755752c1c63ddc4741b06765d0e1263d333e6d7560ceac067b9fa22b1bc9100` |
| 2 | `548d9e40f9e0ea96c89bc4d3bcffaff60f9dcafdc2ea6048032843528b40b831d9ca78c0f0fb217cf7288026029ee7139d2b296c80fd1a32` | `d10e67cf3d2a5006f10e212fa57b146c2cf86d7617b0e75d89886b0abb1c62ac598dcce49fbd80749724a67176256ddd52c230f6af8104ac80` |
| 3 | `167755328c64543ed54be524aebc03f34a165195409d41898f4bc662c034f0632bd5bd73ff6a1081090b3be092df46313017c3bc42757931` | `7212742b479b33414876268f29bbcc762b22cf121fd3572c1d3d83420d8a8a5d9a0167389e0789f059727e1f1f6382861230d27faf0c149400` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `b058d02a832556dd69b9f6529e8080ddde4143d50e7c123b65b8e29d623ea70058bf7b81af7a7f2281b5d1d0316a7f2d3f6079d8faca9810` | `dda57a2b122bdae9805ef99f0c4ed00ae2b5041f5dc21fc5568084549b22d26065804d19ea8c1639a82f8c9665443ec0fbe94333c34618c880` |
| 2 | `9fb442bb68519f6c1b099e790ffd792260cbeb74fe4dd58ce01788a02d8d9edaf6caff3e8c322c8ec4e6b98f7a72cfb6931b1b7c5d519717` | `768053b900126a1aff4edcd5792bab6bbbf4e066596d2b19aaf47421c3cc01669fc460e10565091cbc8aa812b3f136bd79ea111092580def80` |
| 3 | `8e10b54b4e7de8fbcc5845a080797367e1549414ee1f98de5b772da3f8db95b495d683fc68ead8f90718a24ec37a1f40e8d6bc1fc0d7951e` | `b4516dba2cf940add6e404fe5548d4b6e4d3f35cd152fd89d8dc8be99d73fd06b4c0628b802ba12981956dbc354c403c31755d2e3e0a4b2780` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `9a922b34a0e67c160918c5c13f2037742b65dc14a451b52543864704cf140ced0b976eff580e810d5ed954f640a9bc98ce51a4cd11ff0df1897d56084a1c976a`

#### Final Output

- **Group Public Key**: `5936a41063dd6b78792195f2bf9c4e16b013c296f83ecb6a2e0d096817dc6da8b3a11dffa6b40f1be563ed0b8282b603a58b5a833c941d3e80`

### COCKTAIL(JubJub, BLAKE2b-512)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `8756a0c7322018095abe95f054459a41205055037722761cdebe6a3e6a7bcb05` | `3065d01b5dbf09d93103277f40d13d0629a68fa3a17a34f23f761b5e6bb39618` |
| 2 | `b734c21d6926af2f78db290091fadc0c36488c5cc2160b5ab5144d7007b3da0c` | `77b891f6bc745d07dcab03a00a60ea1779d742a43309db81a2f2700b2a8f166d` |
| 3 | `48f49c804497cd7c094b706a9419087e6f01d26080ea4791f0fd98fa4cf74907` | `713431ed2f1bf47fdf676c2964dfa9ad3da190deeee88d73d246cb52c202ee4d` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `991901cea440b3606f0e22ced3e6d31087946760fed97411d8d3a2ed7e0ab006` | `ce211ca67cb434c9d2b9721acf2d4615c28037a86b0fc206cae276e60ab05088` |
| 2 | `17e3f0beaf59ee0a4f73a27686a87dfe816461797538d18b0de3a7173de97c0c` | `439f2ae10fcbcfb39ed238aa50d3b7c9affcd570768a79f8b89af07250c79dec` |
| 3 | `de7fe9d85b6492e4abc75a52a549bf457cf92691eb5bc6ff994279dc1013cc03` | `c974fe1912d879ef6241a945755f2914e780940f6ef6d9113525ce8e9440b170` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `e0c9514f613fcccd0c72d38ad7dad66b92efe6679531eb3c78c2bfea31f51f87fe33b4075dd249545774228efd7f1bcfb0ff8ebd801838fe0190237d44f62cbc`

#### Final Output

- **Group Public Key**: `9ea64045a72f3f56522931e22cd692dfd6b007b566b92bb152932c8cb9df9a99`

### COCKTAIL(Pallas, BLAKE2b-512)

#### Configuration

| Participant | Static Secret Key | Static Public Key |
|-------------|-------------------|-------------------|
| 1 | `dea9ef4347bc98004ca7542d8a0e3ccb1c2f481a0db1d8e86f9a1eb3a50b3636` | `c2647de9413e06ca0310d2233b911df9846056fedcde7ddc27cdc812328cfa2e` |
| 2 | `7c0f700861533daccfa018bb5e4e27ecc6ecf20140a640ecd1e851fab0df7d3f` | `6acafb1a30025829365370af851f0da90472082c8273e8cd937ce5b6e5ea44b7` |
| 3 | `a4c870fbb031794cc6c4e4e80bad97a4d1e4a5dd52fc120612ad70e0c6721117` | `21449223d7eb20aa7aef16f66222c03dda599e1d9675634fd5a12a0718333730` |

#### Round 2 Outputs

| Participant | Secret Share | Verification Share |
|-------------|--------------|-------------------|
| 1 | `3e990c81e397150313ad0373f1074768cbce03dd7ef707862d90640b96e5991c` | `502a5a29dc706328eee10948920af85475b6eeeade15913c44d63f7d4acce305` |
| 2 | `cc3e48c135f9848ada87c0b00ce2d61d4d54da92914cfc821a70de79a84d9c1a` | `35725b9d1200428599cd49023374c10d2798092cfc0d3b0e5cdfbd1a96369738` |
| 3 | `5ae48301885af411a2627dee27bc66d3ced9b048a4a1f07f075058e8bab59e18` | `0693f6aa6fc6de43819c4d12e07bb8081373d68a2889e5e14d7157358cc9de03` |

#### Round 3 (Transcript Certification)

- **Transcript Hash**: `18a517e56b1187b18dd2bc4a4275ffb955db354b6dcece0f1ab394d7f9d3eba1769300b9bfbfbf1bed003e4ea88c3a28995d40086a6482d192a142afa2a2c207`

#### Final Output

- **Group Public Key**: `94edd28e7713bf0c82c6201a2e2d14b741b776584c8301c840493ee3d1d92288`
