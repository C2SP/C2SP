# COCKTAIL Distributed Key Generation

[c2sp.org/cocktail-dkg](https://c2sp.org/cocktail-dkg)

- **Version**: v0.0.1
- **Authors**: 
  - [Daniel Bourdrez](https://github.com/bytemare)
  - [Soatok Dreamseeker](https://github.com/soatok)
  - [Tjaden Hess](https://github.com/tjade273), *[Trail of Bits](https://trailofbits.com)*
  - COCKTAIL is an independent derivative of [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg/tree/master),
    which was made by:
    - [Tim Ruffing](https://github.com/real-or-random), *Blockstream Research*
    - [Jonas Nick](https://github.com/jonasnick), *Blockstream Research*

## Introduction

Threshold signature schemes (i.e., [FROST (RFC 9591)](https://www.rfc-editor.org/rfc/rfc9591.html)) allow a secret key
be shared among $n$ parties such that any $t$ of the $n$ parties can cooperate to generate a digital signature for the
group public key.

Initializing a $t$-of-$n$ threshold requires a key generation protocol. This can be a **Distributed Key Generation**
(DKG) protocol or a Trusted Dealer approach. RFC 9591 specifies a Trusted Dealer approach and leaves DKG specification
out of scope.

However, [the original FROST paper](https://eprint.iacr.org/2020/852) did specify a DKG protocol based on Verifiable
Secret Sharing, Pedersen commitments, and Proofs of Possession. This protocol is secure only if communications are
performed over a secure channel, with the following requirements:

* Messages are authenticated and encrypted in transit, to prevent man-in-the-middle attacks
* All participants have some consensus mechanism (e.g., a transparency log) so everyone has a consistent view of the
  protocol messages

To satisfy these requirements in a standalone protocol, Nick and Ruffing proposed [ChillDKG](https://github.com/BlockstreamResearch/bip-frost-dkg)
as a Bitcoin Improvement Proposal. Because of its tight coupling to the Bitcoin project, ChillDKG was only specified and
implemented over the secp256k1 elliptic curve group.

> COCKTAIL is a recursive acronym that stands for: "COCKTAIL Orchestrates Cryptographic Key Threshold Agreement for
> Interoperable Libraries."

COCKTAIL is an independent derivative of ChillDKG intended to be used with any FROST ciphersuite.

## Abstract

COCKTAIL-DKG is a standalone, three-round distributed key generation protocol for threshold signature schemes like 
FROST.

COCKTAIL-DKG allows a group of $n$ participants to securely generate a shared group public key and individual secret
shares for a $t$-of-$n$ threshold, without a trusted dealer. The protocol is built on Feldman's Verifiable Secret
Sharing (VSS), uses pairwise ECDH to encrypt shares for transport over insecure channels, and includes a final
certification round to ensure all participants agree on the outcome. It is designed to be ciphersuite-agile, with
specific recommendations for curves like secp256k1, Ed25519 (via Ristretto255), and Ed448 (via Decaf448).

## Design Overview

COCKTAIL-DKG, like ChillDKG before it, starts off with a simplified variant of a Pedersen Commitment with Proof of
Possession protocol, referred to as "SimplPedPop". If SimplPedPop were a standalone protocol, it would depend on an
external *equality check protocol* to ensure all participants received the same messages.

An encryption layer, called "EncPedPop", wraps SimplPedPop with pairwise ECDH to encrypt secret shares.

Finally, an equality check protocol called "CertEq" is built atop EncPedPop to create a standalone protocol.

A **coordinator** is assumed to facilitate message passing between participants. The coordinator is a trusted third
party that is responsible for receiving messages from all participants, aggregating them where necessary, and
broadcasting them to all participants. The coordinator does not have access to any secret information. The role of the
coordinator can be fulfilled by a simple broadcast channel, a peer-to-peer network, or a dedicated server application.

## Supporting Definitions

This section provides detailed definitions for the notation, message formats, and cryptographic primitives used
throughout the COCKTAIL-DKG protocol.

### Notation

- $n$: The total number of participants in the DKG ceremony.
- $t$: The threshold, i.e., the minimum number of participants required to generate a signature.
- $i, j$: Indices representing participants, where $1 <= i, j <= n$.
- $G$: The generator point of the elliptic curve group.
- $q$: The order of the elliptic curve group.
- $f_i(x)$: The secret polynomial of degree $t-1$ generated by participant $i$.
- $a_{i,k}$: The $k$-th coefficient of $f_i(x)$, which is a scalar. $a_{i,0}$ is the primary secret of participant $i$.
- $C_{i,k}$: The public commitment to the coefficient $a_{i,k}$, where $C_{i,k} = a_{i,k} * G$.
- $C_i$: The VSS commitment for participant $i$, which is the vector of all $C_{i,k}$.
- $s_{i,j}$: The secret share of participant $i$'s polynomial evaluated at $j$, i.e., $s_{i,j} = f_i(j)$.
- $d_i$: The long-term static private key for participant $i$, a scalar.
- $P_i$: The long-term static public key for participant $i$, where $P_i = d_i * G$.
- $e_i$: The ephemeral private key for participant $i$ for a single DKG session, a scalar.
- $E_i$: The ephemeral public key for participant $i$, where $E_i = e_i * G$.
- $PoP_i$: A Proof of Possession signature from participant $i$.
- $x_i$: The final, long-lived secret share for participant $i$, where $x_i = \sum_{j=1}^{n} s_{j,i}$.
- $Y_i$: The public verification share for participant $i$.
- $Y$: The final group public key, where $Y = \sum_{j=1}^{n} C_{j,0}$.

### Operations

- $Add(P1, P2)$: Elliptic curve point addition.
- $RandomScalar()$: Generates a cryptographically secure random scalar in the range $[0, q-1]$.
- $H6()$: A ciphersuite-specific key derivation function.
- $Enc()$/$Dec()$: Ciphersuite-specific AEAD encryption/decryption functions.
- $Sign()$/$Verify()$: Ciphersuite-specific digital signature functions for the Proof of Possession.

### Message Formats

All messages exchanged between participants are encoded as byte arrays. The specific encoding of protocol elements is
defined below. Implementations **MUST** adhere to these formats to ensure interoperability.

#### Primitive Types

Let $G$ be an elliptic curve group with a standardized name (e.g., "P-256", "Ed25519", "secp256k1").

* **Scalar**: A scalar is an integer in the range $[0, q-1]$, where $q$ is the order of the group $G$. A scalar is
  encoded as a fixed-size, big-endian byte array. The size is determined by the curve (e.g., 32 bytes for P-256,
  secp256k1, and Ed25519/Ristretto255).
* **Elliptic Curve Point**: An elliptic curve point is encoded in its compressed form, as a fixed-size byte array. The
  size and format are determined by the curve (e.g., 33 bytes for P-256 and secp256k1, 32 bytes for
  Ed25519/Ristretto255).
* **The Point at Infinity**: The point at infinity, which is the identity element of the group, is represented by a byte
  array of the same length as a standard point encoding, but filled with all zero bytes.

#### Protocol Messages

The following messages are exchanged during the COCKTAIL-DKG protocol. They are constructed by concatenating the byte
representations of their constituent parts in the specified order.

**1. $msg_{1|i}$ (Participant -> Coordinator, Round 1)**

This message contains the participant's VSS commitment, their Proof-of-Possession, their ephemeral public key, and the
encrypted shares for all other participants.

* $C_i$: The VSS commitment, which is a list of $t$ elliptic curve points.
    * Format: $C_{i,0} || C_{i,1} || \cdots || C_{i,t-1}$
* $PoP_i$: The Proof of Possession, which is a signature. The size depends on the signature scheme used by the
  ciphersuite.
* $E_i$: The ephemeral public key, an elliptic curve point. 
  * It does not refer to isogenies. Here, E stands for "ephemeral".
* $c_{i,j}$: An encrypted secret share. The size depends on the AEAD scheme used by the ciphersuite.

The full message is the concatenation of these elements:

```math
msg_{1|i} = C_i || PoP_i || E_i || c_{i,1} || c_{i,2} || \cdots || c_{i,n}
```

**2. $msg2$ (Coordinator -> All Participants, Round 2)**

This message aggregates the public information from all participants.

* $C_{j,0}$: The zero-coefficient commitment from participant $j$, an elliptic curve point.
* $PoP_j$: The Proof of Possession from participant $j$.
* $C_{agg}$: The aggregated commitment for non-zero coefficients. This is a list of $t-1$ points.
    * Format: $C_{agg,1} || \cdots || C_{agg,t-1}$
* $E_j$: The ephemeral public key from participant $j$.
* $c_{j,i}$: The ciphertext from participant $j$ intended for participant $i$.

The message broadcast to participant $i$ is structured as:

```math
msg_{2|i} = (C_{1,0} || PoP_1) || \cdots || (C_{n,0} || PoP_n) || C_{agg} || E_1 || \cdots || E_n || c_{1,i} || \cdots || c_{n,i}
```

**3. $sig_i$ (Participant -> Coordinator, CertEq Phase)**

This message contains the participant's signature over the protocol transcript.

* $sig_i$: The signature, created using the participant's static private key $d_i$. The size depends on the signature
  scheme.

**4. Aggregated Signatures (Coordinator -> All Participants, CertEq Phase)**

This is the final message, containing all signatures on the transcript.

* $sig_j$: The signature from participant $j$.

The message is structured as:

```math
aggregated_sigs = sig_1 || sig_2 || \cdots || sig_n
```

### Cryptographic Primitives

As COCKTAIL-DKG is intended to be used in conjunction with [RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html), we
begin our enumeration of named hash functions with "H6".


## Protocol Definition

This section describes the COCKTAIL-DKG protocol in detail.

### Setup

Each participant $i$ is assumed to have:
- A unique identifier $i$ from $1$ to $n$.
- The parameters $n$ (total participants) and $t$ (threshold).
- A long-term static key pair $(d_i, P_i)$.
- A list of the static public keys of all other participants, ${P_1, ..., P_n}$.
- A ciphersuite defining the elliptic curve group, hash function, and AEAD scheme.
- A $context$ string, which should be unique to the DKG session to prevent replay attacks.

### Round 1: Commitment and Encryption

1. **Generate Polynomial:** Participant $i$ generates a secret polynomial $f_i(x)$ of degree $t-1$:
   $f_i(x) = a_{i,0} + a_{i,1}x + \cdots + a_{i,t-1}x^{t-1}$.
   The coefficients $a_{i,k}$ are chosen as random scalars. $a_{i,0}$ is the participant's primary secret share.
2. **Compute VSS Commitment:** Participant $i$ computes a VSS commitment $C_i$ to their polynomial by creating a public
   commitment for each coefficient:
   $C_i = (C_{i,0}, C_{i,1}, \cdots, C_{i,t-1})$, where $C_{i,k} = [a_{i,k}] G$.
3. **Compute Proof of Possession (PoP):** Participant $i$ computes a digital signature $PoP_i$ over the $context$ string
   using the secret $a_{i,0}$ as the private key and $C_{i,0}$ as the public key. The specific signature algorithm is
   defined by the ciphersuite.
4. **Generate Ephemeral Key:** Participant $i$ generates a fresh ephemeral key pair $(e_i, E_i)$ for this session.
5. **Compute and Encrypt Shares:** For each participant $j$ from $1$ to $n$:
    1. **Compute Share:** Participant `i` computes the secret share $s_{i,j} = f_i(j)$.
    2. **Derive Key:** Participant `i` computes an ECDH shared secret with participant $j$'s static public key:
       $S_{i,j} = e_i * P_j$. It then derives a symmetric key and nonce for the AEAD:
       $(k_{i,j}, iv_{i,j}) = H6(S_{i,j}, E_i, P_j, context)$.
    3. **Encrypt Share:** Participant $i$ encrypts the share for participant $j$:
       $c_{i,j} = Enc(s_{i,j}, k_{i,j}, iv_{i,j})$.
6. **Broadcast:** Participant $i$ sends their $msg_{1|i}$ to the coordinator.

### Round 2: Share Decryption and Verification

The coordinator waits to receive $msg_{1|i}$ from all $n$ participants. It then broadcasts a list of all received messages
to every participant. Upon receiving the list of all $msg_{1|i}$ messages, each participant `i` performs the following
steps:

1. **Verify All PoPs:** For each other participant $j$ from $1$ to $n$:
    - Participant $i$ verifies the proof of possession $PoP_j$ using participant $j$'s public commitment $C_{j,0}$ and
      the $context$ string.
    - If any $PoP_j$ is invalid, participant $i$ aborts, identifying participant $j$ as malicious.
2. **Decrypt and Verify Shares:** For each other participant $j$ from $1$ to $n$:
    1. **Derive Key:** Participant $i$ computes the ECDH shared secret with participant $j$'s ephemeral public key:
       $S_{j,i} = d_i * E_j$. They then derive the symmetric key and nonce:
       $(k_{j,i}, iv_{j,i}) = H6(S_{j,i}, E_j, P_i, context)$.
    2. **Decrypt Share:** Participant $i$ decrypts the share sent to them from participant $j$:
       $s_{j,i} = Dec(c_{j,i}, k_{j,i}, iv_{j,i})$.
       If decryption fails, participant $i$ aborts, identifying $j$ as malicious.
    3. **Verify Share:** Participant $i$ verifies the decrypted share $s_{j,i}$ against $j$'s VSS commitment:
       $s_{j,i} * G = \sum_{k=0}^{t-1} i^k * C_{j,k}$
       If the check fails, participant $i$ aborts, identifying $j$ as malicious.
3.  **Compute Final Keys:** If all shares are successfully decrypted and verified:
    1. **Secret Share:** Participant $i$ computes their final long-lived secret share by summing all received shares:
       $x_i = \sum_{j=1}^{n} s_{j,i}$.
    2. **Group Public Key:** Participant $i$ computes the group public key:
       $Y = \sum_{j=1}^n C_{j,0}$.
    3. **Verification Share:** Participant $i$ computes their public verification share $Y_i$. This is done by first
       computing the aggregated commitment for each coefficient $k$:
       $C_{agg,k} = \sum_{j=1}^{n} C_{j,k}$.
       Then, $Y_i = \sum_{k=0}^{t-1} i^k * C_{agg,k}$.
    4. **Final Check:** Participant $i$ performs a final self-consistency check:
       $x_i * G = Y_i$. If this check fails, the participant must abort.

### Round 3: Certification

This round ensures that all honest participants have arrived at the same public state.

1. **Construct Transcript:** Each participant $i$ constructs a canonical byte representation of the final public
   transcript, $T$. The transcript **MUST** include, in a well-defined order and format:
    - The $context$ string.
    - The list of all participants' static public keys ${P_1, \cdots, P_n}$.
    - The list of all VSS commitments ${C_1, \cdots, C_n}$.
    - The list of all PoPs ${PoP_1, \cdots, PoP_n}$.
    - The list of all ephemeral public keys ${E_1, \cdots, E_n}$.
2. **Sign Transcript:** Participant $i$ signs the transcript $T$ with their long-term static private key $d_i$,
   producing a signature $sig_i$.
3. **Broadcast Signature:** Participant $i$ sends $sig_i$ to the coordinator.
4. **Verify Certificate:** The coordinator broadcasts the set of all signatures ${sig_1, \cdots, sig_n}$ to everyone.
   Each participant $i$ verifies every signature $sig_j$ on the transcript $T$ against the public key $P_j$.
5. **Success:** If all signatures are valid, the DKG is successful. The participant stores their secret share $x_i$ and
   the group public key $Y$. The collection of $T$ and all $n$ signatures on it is called a "success certificate" and
   can be stored for auditing.

## Error Handling

A robust implementation of COCKTAIL-DKG **MUST** handle a variety of error conditions. Errors can arise from malformed
messages, invalid cryptographic values, or protocol violations. The ability to distinguish between these cases is
crucial for security and usability.

### Error Categories

We recommend that implementations define distinct error types to represent different failure modes. This allows
applications to react appropriately, whether by retrying an operation, aborting the protocol, or initiating a
blame-finding procedure.

The following categories cover the most common errors:

1. **Parsing and Deserialization Errors**:
    * **Description**: These errors occur when a received message does not conform to the byte-based format specified in
      the `Message Formats` section. This could be due to an incorrect length, an invalid point or scalar encoding, or
      other structural defects.
    * **Action**: An honest participant should never produce a malformed message. If a participant receives such a
      message, it should be treated as evidence of a bug in the sender's implementation or a deliberate protocol
      violation. The protocol should be aborted. If the sender can be identified (e.g., in $msg_{1|i}$), they should be
      flagged as faulty.
2. **Cryptographic Verification Failures**:
    * **Description**: These errors occur when a cryptographic check fails. This category includes:
        * An invalid Proof-of-Possession ($PoP_j$).
        * A VSS share verification failure ($s_{j,i}G \ne \sum_{i}^{k} C_{j,k}$).
        * A failed decryption of an encrypted share ($c_{j,i}$).
        * An invalid signature on the final transcript ($sig_j$).
    * **Action**: A cryptographic failure is a clear indication that a participant is behaving maliciously or has a
      serious bug. The protocol **MUST** be aborted immediately. The participant who sent the invalid data **MUST** be
      identified and blamed. For example, if $PoP_j$ is invalid, participant $j$ is at fault.
3. **Protocol Logic Errors**:
    * **Description**: These errors relate to violations of the protocol's state machine or rules, such as:
        * A participant sending a message at the wrong time.
        * The coordinator broadcasting an inconsistent `msg2` (e.g., omitting a participant's data).
    * **Action**: These errors indicate a faulty participant or coordinator. The protocol should be aborted. If the error
      can be traced to a specific participant, they should be blamed.

### Blame-Finding and Reporting

A key feature of a secure DKG protocol is the ability to identify malicious participants. When an error occurs, the
protocol should not only terminate but also output information about who caused the failure.

* **Coordinator's Role**: The coordinator is in a unique position to detect errors in $msg_{1|i}$ messages. If the
  coordinator receives a malformed message or one with an invalid PoP from participant $i$, it should immediately abort
  the protocol and broadcast a blame message identifying participant $i$ as faulty.
* **Participant's Role**: Participants must validate all data they receive. If a participant $i$ receives an invalid
  $msg2$ from the coordinator, or if it fails to verify a share $s_{j,i}$ from participant $j$, it must abort. In the
  case of an invalid share, participant $i$ can prove that $j$ is cheating by revealing $s_{j,i}$ and showing that it
  does not match the public commitment $C_j$.
* **Error Types**: To facilitate blame, it is recommended that error types carry information about the faulty party.
  For example, an error could be `FaultyParticipantError(participant_index, reason)`.

## Ciphersuites

This section describes the ciphersuites that are specified for use with COCKTAIL. The current scope includes both
[RFC 9591](https://www.rfc-editor.org/rfc/rfc9591.html#name-ciphersuites) and [ZIP-0312](https://zips.z.cash/zip-0312#ciphersuites).

Each ciphersuite defines a key derivation function $H6(x, pk1, pk2, extra)$, an encryption method $Enc(plain, key, iv)$,
and a decryption method $Dec(cipher, key, iv)$. Ciphersuites **SHOULD** use an AEAD mode for $Enc()$ and $Dec()$.

The $H6$ function is used to derive a symmetric key and nonce from an ECDH shared secret. Unless otherwise specified,
it is defined as:

$H6(x, pk1, pk2, extra) = CH(prefix || x || pk1 || pk2 || len(extra) || extra)$

- $CH$: The specified cryptographic hash function (e.g., SHA-512, BLAKE2b-512).
- $prefix$: A ciphersuite-specific byte string (e.g., `COCKTAIL-DKG-Ed25519-SHA512-H6`).
- $x$, $pk1$, $pk2$: The ECDH shared secret, the ephemeral public key, and the static public key, respectively.
- $len(extra)$: The length of the `extra` data, encoded as a little-endian 64-bit integer.
- $extra$: Additional context-specific data.

The output of $H6$ is used to derive the key and nonce for the AEAD.

### Ciphersuite Definitions

- **COCKTAIL(Ed25519, SHA-512)**
  - **`H6` Hash**: SHA-512
  - **`H6` Prefix**: `COCKTAIL-DKG-Ed25519-SHA512-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(Ristretto255, SHA-512)**
  - **`H6` Hash**: SHA-512
  - **`H6` Prefix**: `COCKTAIL-DKG-Ristretto255-SHA512-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(Ed448, SHAKE256)**
  - **`H6` Hash**: SHAKE256 (with a 56-byte output)
  - **`H6` Prefix**: `COCKTAIL-DKG-Ed448-SHAKE256-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(P-256, SHA-256)**
  - **`H6` Hash**: SHA-256
  - **`H6` Prefix**: `COCKTAIL-DKG-P256-SHA256-H6`
  - **Key/Nonce**: The 32-byte `H6` output is the key. The nonce is a 12-byte array of all zeros.
  - **AEAD**: AES-256-GCM

- **COCKTAIL(secp256k1, SHA-256)**
  - **Note**: This ciphersuite **MUST** be backwards-compatible with ChillDKG.
  - **`H6` Definition**: A BIP-340-style tagged hash with the tag `ChillDKG/H`.
    The message is $x || pk1 || pk2 || extra$.
  - **Key/Nonce**: The 32-byte hash output is the key. The nonce is a 12-byte array of all zeros.
  - **AEAD**: AES-256-GCM

- **COCKTAIL(JubJub, BLAKE2b-512)**
  - **Note**: Compatible with [ZIP-0312](https://zips.z.cash/zip-0312#ciphersuites).
  - **`H6` Hash**: BLAKE2b-512 (with a 56-byte output)
  - **`H6` Prefix**: `COCKTAIL-DKG-JubJub-BLAKE2b-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

- **COCKTAIL(Pallas, BLAKE2b-512)**
  - **Note**: Compatible with [ZIP-0312](https://zips.z.cash/zip-0312#ciphersuites).
  - **`H6` Hash**: BLAKE2b-512 (with a 56-byte output)
  - **`H6` Prefix**: `COCKTAIL-DKG-Pallas-BLAKE2b-H6`
  - **Key/Nonce**: The first 32 bytes of the `H6` output are the key, and the next 24 bytes are the nonce.
  - **AEAD**: XChaCha20-Poly1305

## Security Considerations

- **Coordinator Role**: The coordinator is trusted for availability and to correctly broadcast messages, but is not
  trusted with the confidentiality of any secret data. A malicious coordinator can disrupt the protocol by refusing to
  broadcast messages or by sending different messages to different participants, but it cannot learn the secret shares
  or the final group secret key. The final certification round (Round 3) is designed to detect such split-view attacks.
- **Proof of Possession (PoP)**: The PoP in Round 1 prevents a malicious participant from performing a rogue key attack.
  By signing their commitment $C_{i,0}$ with the corresponding secret $a_{i,0}$, each participant proves they actually
  know the secret key they are contributing. Without this, an attacker could contribute a public key for which they
  don't know the private key, leading to an unusable group key.
- **Verifiable Secret Sharing (VSS)**: The Feldman VSS scheme ensures that even if a participant is malicious and sends
  incorrect shares, they will be caught. The check in Round 2, $[s_{j,i}] * G = \sum([i^k] * C_{j,k})$, allows each
  participant to verify that the share they received is consistent with the public commitment. This prevents a malicious
  participant from corrupting the final key.
  - Participant IDs ($i$, $j$, etc.) **MUST NOT** be equal to 0 or a multiple of the elliptic curve group order.
    Respecting this requirement prevents a [zero share attack](https://www.zkdocs.com/docs/zkdocs/protocol-primitives/verifiable-secret-sharing/).
- **Encryption of Shares**: The use of an AEAD to encrypt the secret shares $s_{i,j}$ is crucial. It provides
  confidentiality against an eavesdropper on the communication channel and authenticity to prevent a man-in-the-middle
  from tampering with the shares. The key is derived using an ECDH key exchange, ensuring that only the intended
  recipient can decrypt their share.
- **Cofactor Security**: As noted in the [Ciphersuite-Specific Considerations](#ciphersuite-specific-considerations) 
  section, curves like Ed25519 and Ed448 have small cofactors. It is critical that implementations use prime-order group
  abstractions like Ristretto255 and Decaf448 to prevent small subgroup attacks, where an attacker could submit a 
  low-order point to leak information.
- **Transcript Certification**: The final round where all participants sign the public transcript is vital. It ensures
  that all honest participants have a consistent view of the entire public state of the DKG. If a malicious coordinator
  tried to give different participants different sets of messages, the transcript signatures would not match, and the
  protocol would fail safely. This provides a guarantee of explicit consensus.

### Working with curves with small subgroups

Certain elliptic curves used in cryptography are in the so called Montgomery or Edwards model, picked for particularly
efficient arithmetic. The downsides to these curves is that they have an order which factors as $n = [h] * q$ for some
small value $h$ and large prime $q$. If an attacker can select a point $P$ of order $h$ they can potentially leak
partial information about the secret scalars from the output of $[s] P$. (They specifically learn $s \bmod h$).

Two curves in these families we consider are ed25519 with $h = 8$ and edwards448 with $h = 4$. It is strongly
recommended that, when these curves are required, the safe abstractions (Ristretto255 and Decaf448 respectively) are
used which internal handles the removal of small subgroups and requires less manual work to ensure safety.

However, for some use cases, ed25519 and edwards448 might be used directly. Here, users MUST ensure all points are in
the prime order subgroup q through proper cofactor clearing.

In the case that a protocol requires both the abstractions (Ristretto255 and Decaf448) as well as points on the curves
themselves, then the lifted points must have their potential cofactors cleared. This should be done by computing
$P^{\prime} = [1/h] [h] P$ where $P$ is a point in the group abstraction. The point $P^{\prime}$ can then be safely
used on the curve itself as it will either be a point of order q or when P is the point at infinity, then $P^{\prime}$
will be too.

## Alternatives

- **Trusted Dealer**: The simplest way to generate a threshold key is to have a single trusted party generate the group
  key and distribute the shares. This is much less complex than a DKG, but it introduces a single point of failure and
  requires absolute trust in the dealer. COCKTAIL-DKG is designed for scenarios where such a trusted party is not
  available or desirable.
- **Original FROST DKG**: The DKG specified in the original FROST paper required a secure channel for all
  communications. This means that all messages would need to be encrypted and authenticated between all pairs of
  participants, which can be complex to set up. COCKTAIL-DKG removes this requirement by building in its own encryption
  layer (EncPedPop), making it usable over insecure, unauthenticated channels.

# Appendix A: Pseudocode 

This appendix provides a series of algorithms that describe the COCKTAIL-DKG protocol in a high-level,
implementation-agnostic manner. The notation is meant to be illustrative rather than strictly formal.

### Algorithm 1: Polynomial Generation and VSS Commitment

**Input:**
- `t`: The threshold parameter.
- `G`: The generator point of the elliptic curve group.
- `q`: The order of the elliptic curve group.

**Output:**
- `f`: A secret polynomial of degree `t-1`.
- `C`: A vector of public commitments to the polynomial coefficients.

**Steps:**
1. Initialize an empty polynomial f.
2. Initialize an empty list of commitments C.
3. For k from 0 to t-1:
    1. Generate a random scalar a_k in the range [0, q-1].
    2. Add the term a_k * x^k to the polynomial f.
    3. Compute the commitment C_k = a_k * G.
    4. Append C_k to the list C.
4. Return (f, C).

**Pseudocode:**
```python
function GeneratePolynomial(t, G, q):
    f = new Polynomial()
    C = new List<Point>()

    for k from 0 to t-1:
        a_k = RandomScalar(q)
        f.add_coefficient(a_k)

        C_k = a_k * G
        C.append(C_k)

    return (f, C)
```

---

### Algorithm 2: Secret Share Evaluation

**Input:**
- `f`: A secret polynomial.
- `j`: The index of the recipient participant.

**Output:**
- `s_j`: The secret share for participant `j`.

**Steps:**
1. Evaluate the polynomial f at the point x = j.
2. Let the result be s_j = f(j).
3. Return s_j.

**Pseudocode:**
```python
function EvaluatePolynomial(f, j):
    result = 0
    # iterate from highest degree to lowest
    for a in reverse(f.coefficients):
        result = result * j + a
    return result
```

---

### Algorithm 3: Secret Share Verification

**Input:**
- `s_j`: A secret share received from another participant.
- `j`: The index of the recipient participant (i.e., self).
- `C`: The list of VSS commitments from the sender.
- `G`: The generator point of the elliptic curve group.
- `t`: The threshold parameter.

**Output:**
- `valid`: A boolean indicating if the share is valid.

**Steps:**
1. Compute the public verification point from the share: V = s_j * G.
2. Compute the expected verification point from the commitments:
    1. Initialize an identity point R.
    2. For k from 0 to t-1:
        1. Compute term = (j^k) * C_k.
        2. Add term to R: R = R + term.
3. Compare the points: valid = (V == R).
4. Return valid.

**Pseudocode:**
```python
function VerifyShare(s_ji, i, C_j, G, t):
    # V = s_{j,i} * G
    V = s_ji * G

    # R = sum_{k=0}^{t-1} (i^k * C_{j,k})
    R = IdentityPoint()
    for k from 0 to t-1:
        i_k = power(i, k)
        C_jk = C_j[k]
        term = i_k * C_jk
        R = R + term

    return V == R
```

---

### Algorithm 4: COCKTAIL-DKG Round 1 (Participant `i`)

**Input:**
- `i`: The index of the current participant.
- `t`: The threshold parameter.
- `n`: The total number of participants.
- `cs`: The ciphersuite (providing Group, Hash, AEAD).
- `context`: A session-specific context string.
- `d_i`: The static private key of participant `i`.
- `P_j`: The static public key of every other participant `j`.

**Output:**
- `msg1_i`: The Round 1 message to be broadcast.
- `internal_state`: Values to be stored for the next round (e.g., polynomial, ephemeral key).

**Steps:**
1. Generate Polynomial and VSS Commitment:
    1. (f_i, C_i) = Algorithm1(t, cs.Group.G, cs.Group.q)
2. Compute Proof of Possession (PoP):
    1. Let a_i_0 be the constant term of f_i.
    2. Let C_i_0 be the first commitment in C_i.
    3. PoP_i = Sign(private_key=a_i_0, message=context) (using a scheme compatible with C_i_0).
3. Generate Ephemeral Key:
    1. e_i = cs.Group.RandomScalar()
    2. E_i = e_i * cs.Group.G
4. Compute and Encrypt Shares:
    1. Initialize an empty list encrypted_shares.
    2. For j from 1 to n:
        1. s_i_j = Algorithm2(f_i, j).
        2. Derive ECDH key:
            - ecdh_secret = e_i * P_j
            - (key, nonce) = H6(ecdh_secret, E_i, P_j, context)
        3. Encrypt share:
            - c_i_j = Encrypt(key, nonce, plaintext=s_i_j)
        4. Append c_i_j to encrypted_shares.
5. Construct Message:
    1. msg1_i = (C_i, PoP_i, E_i, encrypted_shares)
6. Store State:
    1. internal_state = (f_i, e_i)
7. Return (msg1_i, internal_state).

**Pseudocode:**
```python
function Round1(i, t, n, cs, context, d_i, AllPublicKeys):
    # 1. Generate Polynomial and VSS Commitment
    (f_i, C_i) = GeneratePolynomial(t, cs.Group.G, cs.Group.q)

    # 2. Compute Proof of Possession (PoP)
    a_i0 = f_i.coefficient(0)
    C_i0 = C_i[0]
    PoP_i = Sign(private_key=a_i0, message=context)

    # 3. Generate Ephemeral Key
    e_i = cs.Group.RandomScalar()
    E_i = e_i * cs.Group.G

    # 4. Compute and Encrypt Shares
    encrypted_shares = new List<Ciphertext>()
    for j from 1 to n:
        s_ij = EvaluatePolynomial(f_i, j)

        # Derive and encrypt
        P_j = AllPublicKeys[j]
        ecdh_secret = e_i * P_j
        (key, nonce) = H6(ecdh_secret, E_i, P_j, context)
        c_ij = Encrypt(key, nonce, plaintext=s_ij)
        encrypted_shares.append(c_ij)

    # 5. Construct and return message
    msg1_i = new Round1Message(C_i, PoP_i, E_i, encrypted_shares)
    internal_state = new State(f_i, e_i)
    return (msg1_i, internal_state)
```

---

### Algorithm 5: COCKTAIL-DKG Round 2 (Participant `i`)

**Input:**
- `i`: The index of the current participant.
- `all_msg1s`: A list of all Round 1 messages from all participants.
- `internal_state`: The state saved from Round 1 (`f_i`, `e_i`).
- `d_i`: The static private key of participant `i`.
- `P_i`: The static public key of participant `i`.
- `cs`: The ciphersuite.
- `context`: The session-specific context string.

**Output:**
- `x_i`: The final secret share for participant `i`.
- `Y`: The group public key.
- `Y_i`: The public verification share for participant `i`.
- `transcript_data`: Public data needed for Round 3.

**Steps:**
1. Initialize an empty list received_shares.
2. Process messages from each participant j:
    1. For j from 1 to n:
        1. Parse (C_j, PoP_j, E_j, encrypted_shares_j) from msg1_j.
        2. Verify PoP:
            - valid_pop = Verify(public_key=C_j_0, signature=PoP_j, message=context)
            - If valid_pop is false, abort and blame participant j.
        3. Decrypt Share:
            - Let c_j_i be the encrypted share from j for i.
            - Derive ECDH key:
                - ecdh_secret = d_i * E_j
                - (key, nonce) = H6(ecdh_secret, E_j, P_i, context)
            - Decrypt:
                - s_j_i = Decrypt(key, nonce, ciphertext=c_j_i)
                - If decryption fails, abort and blame participant j.
        4. Verify Share:
            - valid_share = Algorithm3(s_j_i, i, C_j, cs.Group.G, t)
            - If valid_share is false, abort and blame participant j.
        5. Add s_j_i to received_shares.
3. Compute Final Keys:
    1. x_i = sum(received_shares) (scalar addition).
    2. Y = sum(C_j_0 for all j) (point addition).
    3. Compute Verification Share Y_i:
        1. Initialize Y_i to the identity point.
        2. For k from 0 to t-1:
            - C_agg_k = sum(C_j_k for all j) (point addition).
            - term = (i^k) * C_agg_k
            - Y_i = Y_i + term
    4. Final Check:
        - If x_i * cs.Group.G != Y_i, abort (protocol failure).
4. Prepare for Round 3:
    1. transcript_data = (all_msg1s, context, all_static_public_keys)
5. Return (x_i, Y, Y_i, transcript_data).

**Pseudocode:**
```python
function Round2(i, all_msg1s, internal_state, d_i, P_i, cs, context):
    received_shares = new List<Scalar>()

    # 1. Process messages from each participant j
    for j from 1 to n:
        msg1_j = all_msg1s[j]
        C_j, PoP_j, E_j = msg1_j.C, msg1_j.PoP, msg1_j.E

        # Verify PoP
        if not Verify(public_key=C_j[0], signature=PoP_j, message=context):
            abort("Invalid PoP from participant", j)

        # Decrypt Share
        c_ji = msg1_j.encrypted_shares[i]
        ecdh_secret = d_i * E_j
        (key, nonce) = H6(ecdh_secret, E_j, P_i, context)
        s_ji = Decrypt(key, nonce, ciphertext=c_ji)
        if s_ji is null:
            abort("Failed to decrypt share from participant", j)

        # Verify Share
        if not VerifyShare(s_ji, i, C_j, cs.Group.G, t):
            abort("Invalid share from participant", j)

        received_shares.append(s_ji)

    # 2. Compute Final Keys
    x_i = sum(received_shares)
    Y = sum(all_msg1s[j].C[0] for j in 1..n)

    # Compute Verification Share Y_i
    Y_i = IdentityPoint()
    for k from 0 to t-1:
        C_agg_k = sum(all_msg1s[j].C[k] for j in 1..n)
        term = power(i, k) * C_agg_k
        Y_i = Y_i + term

    # Final self-consistency check
    if (x_i * cs.Group.G) != Y_i:
        abort("Final check failed; internal inconsistency")

    transcript_data = new TranscriptData(all_msg1s, context, AllPublicKeys)
    return (x_i, Y, Y_i, transcript_data)
```

---

### Algorithm 6: COCKTAIL-DKG Round 3 (Participant `i`)

**Input:**
- `i`: The index of the current participant.
- `d_i`: The static private key of participant `i`.
- `P_j`: The static public key of every other participant `j`.
- `transcript_data`: The public data from Round 2.

**Output:**
- `success`: A boolean indicating the protocol completed successfully.

**Steps:**
1. Construct Transcript:
    1. T = CanonicalEncode(transcript_data)
2. Sign Transcript:
    1. sig_i = Sign(private_key=d_i, message=T)
3. Broadcast and Receive Signatures:
    1. Send sig_i to the coordinator.
    2. Receive all_signatures from the coordinator.
4. Verify All Signatures:
    1. For j from 1 to n:
        1. Let sig_j be the signature from participant j.
        2. valid_sig = Verify(public_key=P_j, signature=sig_j, message=T)
        3. If valid_sig is false, abort and blame participant j.
5. Success:
    1. success = true
6. Return success.

**Pseudocode:**
```python
function Round3(i, d_i, AllPublicKeys, transcript_data):
    # 1. Construct and sign transcript
    T = CanonicalEncode(transcript_data)
    sig_i = Sign(private_key=d_i, message=T)

    # 2. Broadcast and receive signatures
    all_signatures = broadcast_and_receive(sig_i)

    # 3. Verify all signatures
    for j from 1 to n:
        sig_j = all_signatures[j]
        P_j = AllPublicKeys[j]
        if not Verify(public_key=P_j, signature=sig_j, message=T):
            abort("Invalid transcript signature from participant", j)

    return true # Success
```

# Appendix B: Test Vectors

This section provides a set of test vectors for a 2-of-3 DKG for various ciphersuites.
The vectors were generated deterministically and can be used to verify the correctness of an implementation.

## COCKTAIL(Ed25519, SHA-512)

## COCKTAIL(Ristretto255, SHA-512)

## COCKTAIL(Ed448, SHAKE256)

## COCKTAIL(P-256, SHA-256)

## COCKTAIL(secp256k1, SHA-256)

## COCKTAIL(JubJub, BLAKE2b-512)

## COCKTAIL(Pallas, BLAKE2b-512)
